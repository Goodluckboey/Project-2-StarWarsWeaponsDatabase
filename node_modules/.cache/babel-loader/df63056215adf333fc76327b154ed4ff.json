{"ast":null,"code":"/*!\n * Splide.js\n * Version  : 3.6.9\n * License  : MIT\n * Copyright: 2021 Naotoshi Fujita\n */\nconst PROJECT_CODE = \"splide\";\nconst DATA_ATTRIBUTE = `data-${PROJECT_CODE}`;\nconst CREATED = 1;\nconst MOUNTED = 2;\nconst IDLE = 3;\nconst MOVING = 4;\nconst DESTROYED = 5;\nconst STATES = {\n  CREATED,\n  MOUNTED,\n  IDLE,\n  MOVING,\n  DESTROYED\n};\nconst DEFAULT_EVENT_PRIORITY = 10;\nconst DEFAULT_USER_EVENT_PRIORITY = 20;\n\nfunction empty(array) {\n  array.length = 0;\n}\n\nfunction isObject(subject) {\n  return !isNull(subject) && typeof subject === \"object\";\n}\n\nfunction isArray(subject) {\n  return Array.isArray(subject);\n}\n\nfunction isFunction(subject) {\n  return typeof subject === \"function\";\n}\n\nfunction isString(subject) {\n  return typeof subject === \"string\";\n}\n\nfunction isUndefined(subject) {\n  return typeof subject === \"undefined\";\n}\n\nfunction isNull(subject) {\n  return subject === null;\n}\n\nfunction isHTMLElement(subject) {\n  return subject instanceof HTMLElement;\n}\n\nfunction toArray(value) {\n  return isArray(value) ? value : [value];\n}\n\nfunction forEach(values, iteratee) {\n  toArray(values).forEach(iteratee);\n}\n\nfunction includes(array, value) {\n  return array.indexOf(value) > -1;\n}\n\nfunction push(array, items) {\n  array.push(...toArray(items));\n  return array;\n}\n\nconst arrayProto = Array.prototype;\n\nfunction slice(arrayLike, start, end) {\n  return arrayProto.slice.call(arrayLike, start, end);\n}\n\nfunction find(arrayLike, predicate) {\n  return slice(arrayLike).filter(predicate)[0];\n}\n\nfunction toggleClass(elm, classes, add) {\n  if (elm) {\n    forEach(classes, name => {\n      if (name) {\n        elm.classList[add ? \"add\" : \"remove\"](name);\n      }\n    });\n  }\n}\n\nfunction addClass(elm, classes) {\n  toggleClass(elm, isString(classes) ? classes.split(\" \") : classes, true);\n}\n\nfunction append(parent, children) {\n  forEach(children, parent.appendChild.bind(parent));\n}\n\nfunction before(nodes, ref) {\n  forEach(nodes, node => {\n    const parent = ref.parentNode;\n\n    if (parent) {\n      parent.insertBefore(node, ref);\n    }\n  });\n}\n\nfunction matches(elm, selector) {\n  return isHTMLElement(elm) && (elm[\"msMatchesSelector\"] || elm.matches).call(elm, selector);\n}\n\nfunction children(parent, selector) {\n  return parent ? slice(parent.children).filter(child => matches(child, selector)) : [];\n}\n\nfunction child(parent, selector) {\n  return selector ? children(parent, selector)[0] : parent.firstElementChild;\n}\n\nfunction forOwn(object, iteratee, right) {\n  if (object) {\n    let keys = Object.keys(object);\n    keys = right ? keys.reverse() : keys;\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      if (key !== \"__proto__\") {\n        if (iteratee(object[key], key) === false) {\n          break;\n        }\n      }\n    }\n  }\n\n  return object;\n}\n\nfunction assign(object) {\n  slice(arguments, 1).forEach(source => {\n    forOwn(source, (value, key) => {\n      object[key] = source[key];\n    });\n  });\n  return object;\n}\n\nfunction merge(object, source) {\n  forOwn(source, (value, key) => {\n    if (isArray(value)) {\n      object[key] = value.slice();\n    } else if (isObject(value)) {\n      object[key] = merge(isObject(object[key]) ? object[key] : {}, value);\n    } else {\n      object[key] = value;\n    }\n  });\n  return object;\n}\n\nfunction removeAttribute(elm, attrs) {\n  if (elm) {\n    forEach(attrs, attr => {\n      elm.removeAttribute(attr);\n    });\n  }\n}\n\nfunction setAttribute(elm, attrs, value) {\n  if (isObject(attrs)) {\n    forOwn(attrs, (value2, name) => {\n      setAttribute(elm, name, value2);\n    });\n  } else {\n    isNull(value) ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));\n  }\n}\n\nfunction create(tag, attrs, parent) {\n  const elm = document.createElement(tag);\n\n  if (attrs) {\n    isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);\n  }\n\n  parent && append(parent, elm);\n  return elm;\n}\n\nfunction style(elm, prop, value) {\n  if (isUndefined(value)) {\n    return getComputedStyle(elm)[prop];\n  }\n\n  if (!isNull(value)) {\n    const {\n      style: style2\n    } = elm;\n    value = `${value}`;\n\n    if (style2[prop] !== value) {\n      style2[prop] = value;\n    }\n  }\n}\n\nfunction display(elm, display2) {\n  style(elm, \"display\", display2);\n}\n\nfunction focus(elm) {\n  elm[\"setActive\"] && elm[\"setActive\"]() || elm.focus({\n    preventScroll: true\n  });\n}\n\nfunction getAttribute(elm, attr) {\n  return elm.getAttribute(attr);\n}\n\nfunction hasClass(elm, className) {\n  return elm && elm.classList.contains(className);\n}\n\nfunction rect(target) {\n  return target.getBoundingClientRect();\n}\n\nfunction remove(nodes) {\n  forEach(nodes, node => {\n    if (node && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  });\n}\n\nfunction measure(parent, value) {\n  if (isString(value)) {\n    const div = create(\"div\", {\n      style: `width: ${value}; position: absolute;`\n    }, parent);\n    value = rect(div).width;\n    remove(div);\n  }\n\n  return value;\n}\n\nfunction parseHtml(html) {\n  return child(new DOMParser().parseFromString(html, \"text/html\").body);\n}\n\nfunction prevent(e, stopPropagation) {\n  e.preventDefault();\n\n  if (stopPropagation) {\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n  }\n}\n\nfunction query(parent, selector) {\n  return parent && parent.querySelector(selector);\n}\n\nfunction queryAll(parent, selector) {\n  return slice(parent.querySelectorAll(selector));\n}\n\nfunction removeClass(elm, classes) {\n  toggleClass(elm, classes, false);\n}\n\nfunction unit(value) {\n  return isString(value) ? value : value ? `${value}px` : \"\";\n}\n\nfunction assert(condition) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n\n  if (!condition) {\n    throw new Error(`[${PROJECT_CODE}] ${message}`);\n  }\n}\n\nfunction nextTick(callback) {\n  setTimeout(callback);\n}\n\nconst noop = () => {};\n\nfunction raf(func) {\n  return requestAnimationFrame(func);\n}\n\nconst {\n  min,\n  max,\n  floor,\n  ceil,\n  abs\n} = Math;\n\nfunction approximatelyEqual(x, y, epsilon) {\n  return abs(x - y) < epsilon;\n}\n\nfunction between(number, minOrMax, maxOrMin, exclusive) {\n  const minimum = min(minOrMax, maxOrMin);\n  const maximum = max(minOrMax, maxOrMin);\n  return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;\n}\n\nfunction clamp(number, x, y) {\n  const minimum = min(x, y);\n  const maximum = max(x, y);\n  return min(max(minimum, number), maximum);\n}\n\nfunction sign(x) {\n  return +(x > 0) - +(x < 0);\n}\n\nfunction camelToKebab(string) {\n  return string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\nfunction format(string, replacements) {\n  forEach(replacements, replacement => {\n    string = string.replace(\"%s\", `${replacement}`);\n  });\n  return string;\n}\n\nfunction pad(number) {\n  return number < 10 ? `0${number}` : `${number}`;\n}\n\nconst ids = {};\n\nfunction uniqueId(prefix) {\n  return `${prefix}${pad(ids[prefix] = (ids[prefix] || 0) + 1)}`;\n}\n\nfunction EventBus() {\n  let handlers = {};\n\n  function on(events, callback, key) {\n    let priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_EVENT_PRIORITY;\n    forEachEvent(events, (event, namespace) => {\n      handlers[event] = handlers[event] || [];\n      push(handlers[event], {\n        _event: event,\n        _callback: callback,\n        _namespace: namespace,\n        _priority: priority,\n        _key: key\n      }).sort((handler1, handler2) => handler1._priority - handler2._priority);\n    });\n  }\n\n  function off(events, key) {\n    forEachEvent(events, (event, namespace) => {\n      const eventHandlers = handlers[event];\n      handlers[event] = eventHandlers && eventHandlers.filter(handler => {\n        return handler._key ? handler._key !== key : key || handler._namespace !== namespace;\n      });\n    });\n  }\n\n  function offBy(key) {\n    forOwn(handlers, (eventHandlers, event) => {\n      off(event, key);\n    });\n  }\n\n  function emit(event) {\n    (handlers[event] || []).forEach(handler => {\n      handler._callback.apply(handler, slice(arguments, 1));\n    });\n  }\n\n  function destroy() {\n    handlers = {};\n  }\n\n  function forEachEvent(events, iteratee) {\n    toArray(events).join(\" \").split(\" \").forEach(eventNS => {\n      const fragments = eventNS.split(\".\");\n      iteratee(fragments[0], fragments[1]);\n    });\n  }\n\n  return {\n    on,\n    off,\n    offBy,\n    emit,\n    destroy\n  };\n}\n\nconst EVENT_MOUNTED = \"mounted\";\nconst EVENT_READY = \"ready\";\nconst EVENT_MOVE = \"move\";\nconst EVENT_MOVED = \"moved\";\nconst EVENT_SHIFTED = \"shifted\";\nconst EVENT_CLICK = \"click\";\nconst EVENT_ACTIVE = \"active\";\nconst EVENT_INACTIVE = \"inactive\";\nconst EVENT_VISIBLE = \"visible\";\nconst EVENT_HIDDEN = \"hidden\";\nconst EVENT_SLIDE_KEYDOWN = \"slide:keydown\";\nconst EVENT_REFRESH = \"refresh\";\nconst EVENT_UPDATED = \"updated\";\nconst EVENT_RESIZE = \"resize\";\nconst EVENT_RESIZED = \"resized\";\nconst EVENT_REPOSITIONED = \"repositioned\";\nconst EVENT_DRAG = \"drag\";\nconst EVENT_DRAGGING = \"dragging\";\nconst EVENT_DRAGGED = \"dragged\";\nconst EVENT_SCROLL = \"scroll\";\nconst EVENT_SCROLLED = \"scrolled\";\nconst EVENT_DESTROY = \"destroy\";\nconst EVENT_ARROWS_MOUNTED = \"arrows:mounted\";\nconst EVENT_ARROWS_UPDATED = \"arrows:updated\";\nconst EVENT_PAGINATION_MOUNTED = \"pagination:mounted\";\nconst EVENT_PAGINATION_UPDATED = \"pagination:updated\";\nconst EVENT_NAVIGATION_MOUNTED = \"navigation:mounted\";\nconst EVENT_AUTOPLAY_PLAY = \"autoplay:play\";\nconst EVENT_AUTOPLAY_PLAYING = \"autoplay:playing\";\nconst EVENT_AUTOPLAY_PAUSE = \"autoplay:pause\";\nconst EVENT_LAZYLOAD_LOADED = \"lazyload:loaded\";\n\nfunction EventInterface(Splide2) {\n  const {\n    event\n  } = Splide2;\n  const key = {};\n  let listeners = [];\n\n  function on(events, callback, priority) {\n    event.on(events, callback, key, priority);\n  }\n\n  function off(events) {\n    event.off(events, key);\n  }\n\n  function bind(targets, events, callback, options) {\n    forEachEvent(targets, events, (target, event2) => {\n      listeners.push([target, event2, callback, options]);\n      target.addEventListener(event2, callback, options);\n    });\n  }\n\n  function unbind(targets, events, callback) {\n    forEachEvent(targets, events, (target, event2) => {\n      listeners = listeners.filter(listener => {\n        if (listener[0] === target && listener[1] === event2 && (!callback || listener[2] === callback)) {\n          target.removeEventListener(event2, listener[2], listener[3]);\n          return false;\n        }\n\n        return true;\n      });\n    });\n  }\n\n  function forEachEvent(targets, events, iteratee) {\n    forEach(targets, target => {\n      if (target) {\n        events.split(\" \").forEach(iteratee.bind(null, target));\n      }\n    });\n  }\n\n  function destroy() {\n    listeners = listeners.filter(data => unbind(data[0], data[1]));\n    event.offBy(key);\n  }\n\n  event.on(EVENT_DESTROY, destroy, key);\n  return {\n    on,\n    off,\n    emit: event.emit,\n    bind,\n    unbind,\n    destroy\n  };\n}\n\nfunction RequestInterval(interval, onInterval, onUpdate, limit) {\n  const {\n    now\n  } = Date;\n  let startTime;\n  let rate = 0;\n  let id;\n  let paused = true;\n  let count = 0;\n\n  function update() {\n    if (!paused) {\n      const elapsed = now() - startTime;\n\n      if (elapsed >= interval) {\n        rate = 1;\n        startTime = now();\n      } else {\n        rate = elapsed / interval;\n      }\n\n      if (onUpdate) {\n        onUpdate(rate);\n      }\n\n      if (rate === 1) {\n        onInterval();\n\n        if (limit && ++count >= limit) {\n          return pause();\n        }\n      }\n\n      raf(update);\n    }\n  }\n\n  function start(resume) {\n    !resume && cancel();\n    startTime = now() - (resume ? rate * interval : 0);\n    paused = false;\n    raf(update);\n  }\n\n  function pause() {\n    paused = true;\n  }\n\n  function rewind() {\n    startTime = now();\n    rate = 0;\n\n    if (onUpdate) {\n      onUpdate(rate);\n    }\n  }\n\n  function cancel() {\n    cancelAnimationFrame(id);\n    rate = 0;\n    id = 0;\n    paused = true;\n  }\n\n  function set(time) {\n    interval = time;\n  }\n\n  function isPaused() {\n    return paused;\n  }\n\n  return {\n    start,\n    rewind,\n    pause,\n    cancel,\n    set,\n    isPaused\n  };\n}\n\nfunction State(initialState) {\n  let state = initialState;\n\n  function set(value) {\n    state = value;\n  }\n\n  function is(states) {\n    return includes(toArray(states), state);\n  }\n\n  return {\n    set,\n    is\n  };\n}\n\nfunction Throttle(func, duration) {\n  let interval;\n\n  function throttled() {\n    if (!interval) {\n      interval = RequestInterval(duration || 0, () => {\n        func.apply(this, arguments);\n        interval = null;\n      }, null, 1);\n      interval.start();\n    }\n  }\n\n  return throttled;\n}\n\nfunction Options(Splide2, Components2, options) {\n  const throttledObserve = Throttle(observe);\n  let initialOptions;\n  let points;\n  let currPoint;\n\n  function setup() {\n    try {\n      merge(options, JSON.parse(getAttribute(Splide2.root, DATA_ATTRIBUTE)));\n    } catch (e) {\n      assert(false, e.message);\n    }\n\n    initialOptions = merge({}, options);\n    const {\n      breakpoints\n    } = options;\n\n    if (breakpoints) {\n      const isMin = options.mediaQuery === \"min\";\n      points = Object.keys(breakpoints).sort((n, m) => isMin ? +m - +n : +n - +m).map(point => [point, matchMedia(`(${isMin ? \"min\" : \"max\"}-width:${point}px)`)]);\n      observe();\n    }\n  }\n\n  function mount() {\n    if (points) {\n      addEventListener(\"resize\", throttledObserve);\n    }\n  }\n\n  function destroy(completely) {\n    if (completely) {\n      removeEventListener(\"resize\", throttledObserve);\n    }\n  }\n\n  function observe() {\n    const item = find(points, item2 => item2[1].matches) || [];\n\n    if (item[0] !== currPoint) {\n      onMatch(currPoint = item[0]);\n    }\n  }\n\n  function onMatch(point) {\n    const newOptions = options.breakpoints[point] || initialOptions;\n\n    if (newOptions.destroy) {\n      Splide2.options = initialOptions;\n      Splide2.destroy(newOptions.destroy === \"completely\");\n    } else {\n      if (Splide2.state.is(DESTROYED)) {\n        destroy(true);\n        Splide2.mount();\n      }\n\n      Splide2.options = newOptions;\n    }\n  }\n\n  return {\n    setup,\n    mount,\n    destroy\n  };\n}\n\nconst RTL = \"rtl\";\nconst TTB = \"ttb\";\nconst ORIENTATION_MAP = {\n  marginRight: [\"marginBottom\", \"marginLeft\"],\n  autoWidth: [\"autoHeight\"],\n  fixedWidth: [\"fixedHeight\"],\n  paddingLeft: [\"paddingTop\", \"paddingRight\"],\n  paddingRight: [\"paddingBottom\", \"paddingLeft\"],\n  width: [\"height\"],\n  left: [\"top\", \"right\"],\n  right: [\"bottom\", \"left\"],\n  x: [\"y\"],\n  X: [\"Y\"],\n  Y: [\"X\"],\n  ArrowLeft: [\"ArrowUp\", \"ArrowRight\"],\n  ArrowRight: [\"ArrowDown\", \"ArrowLeft\"]\n};\n\nfunction Direction(Splide2, Components2, options) {\n  function resolve(prop, axisOnly) {\n    const {\n      direction\n    } = options;\n    const index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;\n    return ORIENTATION_MAP[prop][index] || prop;\n  }\n\n  function orient(value) {\n    return value * (options.direction === RTL ? 1 : -1);\n  }\n\n  return {\n    resolve,\n    orient\n  };\n}\n\nconst CLASS_ROOT = PROJECT_CODE;\nconst CLASS_SLIDER = `${PROJECT_CODE}__slider`;\nconst CLASS_TRACK = `${PROJECT_CODE}__track`;\nconst CLASS_LIST = `${PROJECT_CODE}__list`;\nconst CLASS_SLIDE = `${PROJECT_CODE}__slide`;\nconst CLASS_CLONE = `${CLASS_SLIDE}--clone`;\nconst CLASS_CONTAINER = `${CLASS_SLIDE}__container`;\nconst CLASS_ARROWS = `${PROJECT_CODE}__arrows`;\nconst CLASS_ARROW = `${PROJECT_CODE}__arrow`;\nconst CLASS_ARROW_PREV = `${CLASS_ARROW}--prev`;\nconst CLASS_ARROW_NEXT = `${CLASS_ARROW}--next`;\nconst CLASS_PAGINATION = `${PROJECT_CODE}__pagination`;\nconst CLASS_PAGINATION_PAGE = `${CLASS_PAGINATION}__page`;\nconst CLASS_PROGRESS = `${PROJECT_CODE}__progress`;\nconst CLASS_PROGRESS_BAR = `${CLASS_PROGRESS}__bar`;\nconst CLASS_AUTOPLAY = `${PROJECT_CODE}__autoplay`;\nconst CLASS_PLAY = `${PROJECT_CODE}__play`;\nconst CLASS_PAUSE = `${PROJECT_CODE}__pause`;\nconst CLASS_SPINNER = `${PROJECT_CODE}__spinner`;\nconst CLASS_INITIALIZED = \"is-initialized\";\nconst CLASS_ACTIVE = \"is-active\";\nconst CLASS_PREV = \"is-prev\";\nconst CLASS_NEXT = \"is-next\";\nconst CLASS_VISIBLE = \"is-visible\";\nconst CLASS_LOADING = \"is-loading\";\nconst STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING];\nconst CLASSES = {\n  slide: CLASS_SLIDE,\n  clone: CLASS_CLONE,\n  arrows: CLASS_ARROWS,\n  arrow: CLASS_ARROW,\n  prev: CLASS_ARROW_PREV,\n  next: CLASS_ARROW_NEXT,\n  pagination: CLASS_PAGINATION,\n  page: CLASS_PAGINATION_PAGE,\n  spinner: CLASS_SPINNER\n};\n\nfunction Elements(Splide2, Components2, options) {\n  const {\n    on\n  } = EventInterface(Splide2);\n  const {\n    root\n  } = Splide2;\n  const elements = {};\n  const slides = [];\n  let classes;\n  let slider;\n  let track;\n  let list;\n\n  function setup() {\n    collect();\n    identify();\n    addClass(root, classes = getClasses());\n  }\n\n  function mount() {\n    on(EVENT_REFRESH, refresh, DEFAULT_EVENT_PRIORITY - 2);\n    on(EVENT_UPDATED, update);\n  }\n\n  function destroy() {\n    [root, track, list].forEach(elm => {\n      removeAttribute(elm, \"style\");\n    });\n    empty(slides);\n    removeClass(root, classes);\n  }\n\n  function refresh() {\n    destroy();\n    setup();\n  }\n\n  function update() {\n    removeClass(root, classes);\n    addClass(root, classes = getClasses());\n  }\n\n  function collect() {\n    slider = child(root, `.${CLASS_SLIDER}`);\n    track = query(root, `.${CLASS_TRACK}`);\n    list = child(track, `.${CLASS_LIST}`);\n    assert(track && list, \"A track/list element is missing.\");\n    push(slides, children(list, `.${CLASS_SLIDE}:not(.${CLASS_CLONE})`));\n    const autoplay = find(`.${CLASS_AUTOPLAY}`);\n    const arrows = find(`.${CLASS_ARROWS}`);\n    assign(elements, {\n      root,\n      slider,\n      track,\n      list,\n      slides,\n      arrows,\n      autoplay,\n      prev: query(arrows, `.${CLASS_ARROW_PREV}`),\n      next: query(arrows, `.${CLASS_ARROW_NEXT}`),\n      bar: query(find(`.${CLASS_PROGRESS}`), `.${CLASS_PROGRESS_BAR}`),\n      play: query(autoplay, `.${CLASS_PLAY}`),\n      pause: query(autoplay, `.${CLASS_PAUSE}`)\n    });\n  }\n\n  function identify() {\n    const id = root.id || uniqueId(PROJECT_CODE);\n    root.id = id;\n    track.id = track.id || `${id}-track`;\n    list.id = list.id || `${id}-list`;\n  }\n\n  function find(selector) {\n    return child(root, selector) || child(slider, selector);\n  }\n\n  function getClasses() {\n    return [`${CLASS_ROOT}--${options.type}`, `${CLASS_ROOT}--${options.direction}`, options.drag && `${CLASS_ROOT}--draggable`, options.isNavigation && `${CLASS_ROOT}--nav`, CLASS_ACTIVE];\n  }\n\n  return assign(elements, {\n    setup,\n    mount,\n    destroy\n  });\n}\n\nconst ROLE = \"role\";\nconst ARIA_CONTROLS = \"aria-controls\";\nconst ARIA_CURRENT = \"aria-current\";\nconst ARIA_LABEL = \"aria-label\";\nconst ARIA_HIDDEN = \"aria-hidden\";\nconst TAB_INDEX = \"tabindex\";\nconst DISABLED = \"disabled\";\nconst ARIA_ORIENTATION = \"aria-orientation\";\nconst ALL_ATTRIBUTES = [ROLE, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_HIDDEN, ARIA_ORIENTATION, TAB_INDEX, DISABLED];\nconst SLIDE = \"slide\";\nconst LOOP = \"loop\";\nconst FADE = \"fade\";\n\nfunction Slide$1(Splide2, index, slideIndex, slide) {\n  const {\n    on,\n    emit,\n    bind,\n    destroy: destroyEvents\n  } = EventInterface(Splide2);\n  const {\n    Components,\n    root,\n    options\n  } = Splide2;\n  const {\n    isNavigation,\n    updateOnMove\n  } = options;\n  const {\n    resolve\n  } = Components.Direction;\n  const styles = getAttribute(slide, \"style\");\n  const isClone = slideIndex > -1;\n  const container = child(slide, `.${CLASS_CONTAINER}`);\n  const focusableNodes = options.focusableNodes && queryAll(slide, options.focusableNodes);\n  let destroyed;\n\n  function mount() {\n    if (!isClone) {\n      slide.id = `${root.id}-slide${pad(index + 1)}`;\n    }\n\n    bind(slide, \"click keydown\", e => {\n      emit(e.type === \"click\" ? EVENT_CLICK : EVENT_SLIDE_KEYDOWN, self, e);\n    });\n    on([EVENT_REFRESH, EVENT_REPOSITIONED, EVENT_SHIFTED, EVENT_MOVED, EVENT_SCROLLED], update);\n    on(EVENT_NAVIGATION_MOUNTED, initNavigation);\n\n    if (updateOnMove) {\n      on(EVENT_MOVE, onMove);\n    }\n  }\n\n  function destroy() {\n    destroyed = true;\n    destroyEvents();\n    removeClass(slide, STATUS_CLASSES);\n    removeAttribute(slide, ALL_ATTRIBUTES);\n    setAttribute(slide, \"style\", styles);\n  }\n\n  function initNavigation() {\n    const idx = isClone ? slideIndex : index;\n    const label = format(options.i18n.slideX, idx + 1);\n    const controls = Splide2.splides.map(target => target.splide.root.id).join(\" \");\n    setAttribute(slide, ARIA_LABEL, label);\n    setAttribute(slide, ARIA_CONTROLS, controls);\n    setAttribute(slide, ROLE, \"menuitem\");\n    updateActivity(isActive());\n  }\n\n  function onMove() {\n    if (!destroyed) {\n      update();\n    }\n  }\n\n  function update() {\n    if (!destroyed) {\n      const {\n        index: currIndex\n      } = Splide2;\n      updateActivity(isActive());\n      updateVisibility(isVisible());\n      toggleClass(slide, CLASS_PREV, index === currIndex - 1);\n      toggleClass(slide, CLASS_NEXT, index === currIndex + 1);\n    }\n  }\n\n  function updateActivity(active) {\n    if (active !== hasClass(slide, CLASS_ACTIVE)) {\n      toggleClass(slide, CLASS_ACTIVE, active);\n\n      if (isNavigation) {\n        setAttribute(slide, ARIA_CURRENT, active || null);\n      }\n\n      emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);\n    }\n  }\n\n  function updateVisibility(visible) {\n    const hidden = !visible && (!isActive() || isClone);\n    setAttribute(slide, ARIA_HIDDEN, hidden || null);\n    setAttribute(slide, TAB_INDEX, !hidden && options.slideFocus ? 0 : null);\n\n    if (focusableNodes) {\n      focusableNodes.forEach(node => {\n        setAttribute(node, TAB_INDEX, hidden ? -1 : null);\n      });\n    }\n\n    if (visible !== hasClass(slide, CLASS_VISIBLE)) {\n      toggleClass(slide, CLASS_VISIBLE, visible);\n      emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);\n    }\n  }\n\n  function style$1(prop, value, useContainer) {\n    style(useContainer && container || slide, prop, value);\n  }\n\n  function isActive() {\n    const {\n      index: curr\n    } = Splide2;\n    return curr === index || options.cloneStatus && curr === slideIndex;\n  }\n\n  function isVisible() {\n    if (Splide2.is(FADE)) {\n      return isActive();\n    }\n\n    const trackRect = rect(Components.Elements.track);\n    const slideRect = rect(slide);\n    const left = resolve(\"left\");\n    const right = resolve(\"right\");\n    return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);\n  }\n\n  function isWithin(from, distance) {\n    let diff = abs(from - index);\n\n    if (!isClone && (options.rewind || Splide2.is(LOOP))) {\n      diff = min(diff, Splide2.length - diff);\n    }\n\n    return diff <= distance;\n  }\n\n  const self = {\n    index,\n    slideIndex,\n    slide,\n    container,\n    isClone,\n    mount,\n    destroy,\n    update,\n    style: style$1,\n    isWithin\n  };\n  return self;\n}\n\nfunction Slides(Splide2, Components2, options) {\n  const {\n    on,\n    emit,\n    bind\n  } = EventInterface(Splide2);\n  const {\n    slides,\n    list\n  } = Components2.Elements;\n  const Slides2 = [];\n\n  function mount() {\n    init();\n    on(EVENT_REFRESH, refresh);\n    on([EVENT_MOUNTED, EVENT_REFRESH], () => {\n      Slides2.sort((Slide1, Slide2) => Slide1.index - Slide2.index);\n    });\n  }\n\n  function init() {\n    slides.forEach((slide, index) => {\n      register(slide, index, -1);\n    });\n  }\n\n  function destroy() {\n    forEach$1(Slide2 => {\n      Slide2.destroy();\n    });\n    empty(Slides2);\n  }\n\n  function refresh() {\n    destroy();\n    init();\n  }\n\n  function update() {\n    forEach$1(Slide2 => {\n      Slide2.update();\n    });\n  }\n\n  function register(slide, index, slideIndex) {\n    const object = Slide$1(Splide2, index, slideIndex, slide);\n    object.mount();\n    Slides2.push(object);\n  }\n\n  function get(excludeClones) {\n    return excludeClones ? filter(Slide2 => !Slide2.isClone) : Slides2;\n  }\n\n  function getIn(page) {\n    const {\n      Controller\n    } = Components2;\n    const index = Controller.toIndex(page);\n    const max = Controller.hasFocus() ? 1 : options.perPage;\n    return filter(Slide2 => between(Slide2.index, index, index + max - 1));\n  }\n\n  function getAt(index) {\n    return filter(index)[0];\n  }\n\n  function add(items, index) {\n    forEach(items, slide => {\n      if (isString(slide)) {\n        slide = parseHtml(slide);\n      }\n\n      if (isHTMLElement(slide)) {\n        const ref = slides[index];\n        ref ? before(slide, ref) : append(list, slide);\n        addClass(slide, options.classes.slide);\n        observeImages(slide, emit.bind(null, EVENT_RESIZE));\n      }\n    });\n    emit(EVENT_REFRESH);\n  }\n\n  function remove$1(matcher) {\n    remove(filter(matcher).map(Slide2 => Slide2.slide));\n    emit(EVENT_REFRESH);\n  }\n\n  function forEach$1(iteratee, excludeClones) {\n    get(excludeClones).forEach(iteratee);\n  }\n\n  function filter(matcher) {\n    return Slides2.filter(isFunction(matcher) ? matcher : Slide2 => isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index));\n  }\n\n  function style(prop, value, useContainer) {\n    forEach$1(Slide2 => {\n      Slide2.style(prop, value, useContainer);\n    });\n  }\n\n  function observeImages(elm, callback) {\n    const images = queryAll(elm, \"img\");\n    let {\n      length\n    } = images;\n\n    if (length) {\n      images.forEach(img => {\n        bind(img, \"load error\", () => {\n          if (! --length) {\n            callback();\n          }\n        });\n      });\n    } else {\n      callback();\n    }\n  }\n\n  function getLength(excludeClones) {\n    return excludeClones ? slides.length : Slides2.length;\n  }\n\n  function isEnough() {\n    return Slides2.length > options.perPage;\n  }\n\n  return {\n    mount,\n    destroy,\n    update,\n    register,\n    get,\n    getIn,\n    getAt,\n    add,\n    remove: remove$1,\n    forEach: forEach$1,\n    filter,\n    style,\n    getLength,\n    isEnough\n  };\n}\n\nfunction Layout(Splide2, Components2, options) {\n  const {\n    on,\n    bind,\n    emit\n  } = EventInterface(Splide2);\n  const {\n    Slides\n  } = Components2;\n  const {\n    resolve\n  } = Components2.Direction;\n  const {\n    root,\n    track,\n    list\n  } = Components2.Elements;\n  const {\n    getAt\n  } = Slides;\n  let vertical;\n  let rootRect;\n\n  function mount() {\n    init();\n    bind(window, \"resize load\", Throttle(emit.bind(this, EVENT_RESIZE)));\n    on([EVENT_UPDATED, EVENT_REFRESH], init);\n    on(EVENT_RESIZE, resize);\n  }\n\n  function init() {\n    rootRect = null;\n    vertical = options.direction === TTB;\n    style(root, \"maxWidth\", unit(options.width));\n    style(track, resolve(\"paddingLeft\"), cssPadding(false));\n    style(track, resolve(\"paddingRight\"), cssPadding(true));\n    resize();\n  }\n\n  function resize() {\n    const newRect = rect(root);\n\n    if (!rootRect || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {\n      style(track, \"height\", cssTrackHeight());\n      Slides.style(resolve(\"marginRight\"), unit(options.gap));\n      Slides.style(\"width\", cssSlideWidth() || null);\n      setSlidesHeight();\n      rootRect = newRect;\n      emit(EVENT_RESIZED);\n    }\n  }\n\n  function setSlidesHeight() {\n    Slides.style(\"height\", cssSlideHeight() || null, true);\n  }\n\n  function cssPadding(right) {\n    const {\n      padding\n    } = options;\n    const prop = resolve(right ? \"right\" : \"left\");\n    return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || \"0px\";\n  }\n\n  function cssTrackHeight() {\n    let height = \"\";\n\n    if (vertical) {\n      height = cssHeight();\n      assert(height, \"height or heightRatio is missing.\");\n      height = `calc(${height} - ${cssPadding(false)} - ${cssPadding(true)})`;\n    }\n\n    return height;\n  }\n\n  function cssHeight() {\n    return unit(options.height || rect(list).width * options.heightRatio);\n  }\n\n  function cssSlideWidth() {\n    return options.autoWidth ? \"\" : unit(options.fixedWidth) || (vertical ? \"\" : cssSlideSize());\n  }\n\n  function cssSlideHeight() {\n    return unit(options.fixedHeight) || (vertical ? options.autoHeight ? \"\" : cssSlideSize() : cssHeight());\n  }\n\n  function cssSlideSize() {\n    const gap = unit(options.gap);\n    return `calc((100%${gap && ` + ${gap}`})/${options.perPage || 1}${gap && ` - ${gap}`})`;\n  }\n\n  function listSize() {\n    return rect(list)[resolve(\"width\")];\n  }\n\n  function slideSize(index, withoutGap) {\n    const Slide = getAt(index || 0);\n    return Slide ? rect(Slide.slide)[resolve(\"width\")] + (withoutGap ? 0 : getGap()) : 0;\n  }\n\n  function totalSize(index, withoutGap) {\n    const Slide = getAt(index);\n\n    if (Slide) {\n      const right = rect(Slide.slide)[resolve(\"right\")];\n      const left = rect(list)[resolve(\"left\")];\n      return abs(right - left) + (withoutGap ? 0 : getGap());\n    }\n\n    return 0;\n  }\n\n  function sliderSize() {\n    return totalSize(Splide2.length - 1, true) - totalSize(-1, true);\n  }\n\n  function getGap() {\n    const Slide = getAt(0);\n    return Slide && parseFloat(style(Slide.slide, resolve(\"marginRight\"))) || 0;\n  }\n\n  function getPadding(right) {\n    return parseFloat(style(track, resolve(`padding${right ? \"Right\" : \"Left\"}`))) || 0;\n  }\n\n  return {\n    mount,\n    listSize,\n    slideSize,\n    sliderSize,\n    totalSize,\n    getPadding\n  };\n}\n\nfunction Clones(Splide2, Components2, options) {\n  const {\n    on,\n    emit\n  } = EventInterface(Splide2);\n  const {\n    Elements,\n    Slides\n  } = Components2;\n  const {\n    resolve\n  } = Components2.Direction;\n  const clones = [];\n  let cloneCount;\n\n  function mount() {\n    init();\n    on(EVENT_REFRESH, refresh);\n    on([EVENT_UPDATED, EVENT_RESIZE], observe);\n  }\n\n  function init() {\n    if (cloneCount = computeCloneCount()) {\n      generate(cloneCount);\n      emit(EVENT_RESIZE);\n    }\n  }\n\n  function destroy() {\n    remove(clones);\n    empty(clones);\n  }\n\n  function refresh() {\n    destroy();\n    init();\n  }\n\n  function observe() {\n    if (cloneCount < computeCloneCount()) {\n      emit(EVENT_REFRESH);\n    }\n  }\n\n  function generate(count) {\n    const slides = Slides.get().slice();\n    const {\n      length\n    } = slides;\n\n    if (length) {\n      while (slides.length < count) {\n        push(slides, slides);\n      }\n\n      push(slides.slice(-count), slides.slice(0, count)).forEach((Slide, index) => {\n        const isHead = index < count;\n        const clone = cloneDeep(Slide.slide, index);\n        isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);\n        push(clones, clone);\n        Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index);\n      });\n    }\n  }\n\n  function cloneDeep(elm, index) {\n    const clone = elm.cloneNode(true);\n    addClass(clone, options.classes.clone);\n    clone.id = `${Splide2.root.id}-clone${pad(index + 1)}`;\n    return clone;\n  }\n\n  function computeCloneCount() {\n    let {\n      clones: clones2\n    } = options;\n\n    if (!Splide2.is(LOOP)) {\n      clones2 = 0;\n    } else if (!clones2) {\n      const fixedSize = measure(Elements.list, options[resolve(\"fixedWidth\")]);\n      const fixedCount = fixedSize && ceil(rect(Elements.track)[resolve(\"width\")] / fixedSize);\n      const baseCount = fixedCount || options[resolve(\"autoWidth\")] && Splide2.length || options.perPage;\n      clones2 = baseCount * (options.drag ? (options.flickMaxPages || 1) + 1 : 2);\n    }\n\n    return clones2;\n  }\n\n  return {\n    mount,\n    destroy\n  };\n}\n\nfunction Move(Splide2, Components2, options) {\n  const {\n    on,\n    emit\n  } = EventInterface(Splide2);\n  const {\n    slideSize,\n    getPadding,\n    totalSize,\n    listSize,\n    sliderSize\n  } = Components2.Layout;\n  const {\n    resolve,\n    orient\n  } = Components2.Direction;\n  const {\n    list,\n    track\n  } = Components2.Elements;\n  let Transition;\n\n  function mount() {\n    Transition = Components2.Transition;\n    on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);\n  }\n\n  function destroy() {\n    removeAttribute(list, \"style\");\n  }\n\n  function reposition() {\n    if (!isBusy()) {\n      Components2.Scroll.cancel();\n      jump(Splide2.index);\n      emit(EVENT_REPOSITIONED);\n    }\n  }\n\n  function move(dest, index, prev, callback) {\n    if (!isBusy()) {\n      const {\n        set\n      } = Splide2.state;\n      const position = getPosition();\n\n      if (dest !== index) {\n        Transition.cancel();\n        translate(shift(position, dest > index), true);\n      }\n\n      set(MOVING);\n      emit(EVENT_MOVE, index, prev, dest);\n      Transition.start(index, () => {\n        set(IDLE);\n        emit(EVENT_MOVED, index, prev, dest);\n\n        if (options.trimSpace === \"move\" && dest !== prev && position === getPosition()) {\n          Components2.Controller.go(dest > prev ? \">\" : \"<\", false, callback);\n        } else {\n          callback && callback();\n        }\n      });\n    }\n  }\n\n  function jump(index) {\n    translate(toPosition(index, true));\n  }\n\n  function translate(position, preventLoop) {\n    if (!Splide2.is(FADE)) {\n      const destination = preventLoop ? position : loop(position);\n      list.style.transform = `translate${resolve(\"X\")}(${destination}px)`;\n      position !== destination && emit(EVENT_SHIFTED);\n    }\n  }\n\n  function loop(position) {\n    if (Splide2.is(LOOP)) {\n      const diff = orient(position - getPosition());\n      const exceededMin = exceededLimit(false, position) && diff < 0;\n      const exceededMax = exceededLimit(true, position) && diff > 0;\n\n      if (exceededMin || exceededMax) {\n        position = shift(position, exceededMax);\n      }\n    }\n\n    return position;\n  }\n\n  function shift(position, backwards) {\n    const excess = position - getLimit(backwards);\n    const size = sliderSize();\n    position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);\n    return position;\n  }\n\n  function cancel() {\n    translate(getPosition());\n    Transition.cancel();\n  }\n\n  function toIndex(position) {\n    const Slides = Components2.Slides.get();\n    let index = 0;\n    let minDistance = Infinity;\n\n    for (let i = 0; i < Slides.length; i++) {\n      const slideIndex = Slides[i].index;\n      const distance = abs(toPosition(slideIndex, true) - position);\n\n      if (distance <= minDistance) {\n        minDistance = distance;\n        index = slideIndex;\n      } else {\n        break;\n      }\n    }\n\n    return index;\n  }\n\n  function toPosition(index, trimming) {\n    const position = orient(totalSize(index - 1) - offset(index));\n    return trimming ? trim(position) : position;\n  }\n\n  function getPosition() {\n    const left = resolve(\"left\");\n    return rect(list)[left] - rect(track)[left] + orient(getPadding(false));\n  }\n\n  function trim(position) {\n    if (options.trimSpace && Splide2.is(SLIDE)) {\n      position = clamp(position, 0, orient(sliderSize() - listSize()));\n    }\n\n    return position;\n  }\n\n  function offset(index) {\n    const {\n      focus\n    } = options;\n    return focus === \"center\" ? (listSize() - slideSize(index, true)) / 2 : +focus * slideSize(index) || 0;\n  }\n\n  function getLimit(max) {\n    return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace);\n  }\n\n  function isBusy() {\n    return Splide2.state.is(MOVING) && options.waitForTransition;\n  }\n\n  function exceededLimit(max, position) {\n    position = isUndefined(position) ? getPosition() : position;\n    const exceededMin = max !== true && orient(position) < orient(getLimit(false));\n    const exceededMax = max !== false && orient(position) > orient(getLimit(true));\n    return exceededMin || exceededMax;\n  }\n\n  return {\n    mount,\n    destroy,\n    move,\n    jump,\n    translate,\n    shift,\n    cancel,\n    toIndex,\n    toPosition,\n    getPosition,\n    getLimit,\n    isBusy,\n    exceededLimit\n  };\n}\n\nfunction Controller(Splide2, Components2, options) {\n  const {\n    on\n  } = EventInterface(Splide2);\n  const {\n    Move\n  } = Components2;\n  const {\n    getPosition,\n    getLimit\n  } = Move;\n  const {\n    isEnough,\n    getLength\n  } = Components2.Slides;\n  const isLoop = Splide2.is(LOOP);\n  const isSlide = Splide2.is(SLIDE);\n  let currIndex = options.start || 0;\n  let prevIndex = currIndex;\n  let slideCount;\n  let perMove;\n  let perPage;\n\n  function mount() {\n    init();\n    on([EVENT_UPDATED, EVENT_REFRESH], init, DEFAULT_EVENT_PRIORITY - 1);\n  }\n\n  function init() {\n    slideCount = getLength(true);\n    perMove = options.perMove;\n    perPage = options.perPage;\n    currIndex = clamp(currIndex, 0, slideCount - 1);\n  }\n\n  function go(control, allowSameIndex, callback) {\n    const dest = parse(control);\n\n    if (options.useScroll) {\n      scroll(dest, true, true, options.speed, callback);\n    } else {\n      const index = loop(dest);\n\n      if (index > -1 && !Move.isBusy() && (allowSameIndex || index !== currIndex)) {\n        setIndex(index);\n        Move.move(dest, index, prevIndex, callback);\n      }\n    }\n  }\n\n  function scroll(destination, useIndex, snap, duration, callback) {\n    const dest = useIndex ? destination : toDest(destination);\n    Components2.Scroll.scroll(useIndex || snap ? Move.toPosition(dest, true) : destination, duration, () => {\n      setIndex(Move.toIndex(Move.getPosition()));\n      callback && callback();\n    });\n  }\n\n  function parse(control) {\n    let index = currIndex;\n\n    if (isString(control)) {\n      const [, indicator, number] = control.match(/([+\\-<>])(\\d+)?/) || [];\n\n      if (indicator === \"+\" || indicator === \"-\") {\n        index = computeDestIndex(currIndex + +`${indicator}${+number || 1}`, currIndex, true);\n      } else if (indicator === \">\") {\n        index = number ? toIndex(+number) : getNext(true);\n      } else if (indicator === \"<\") {\n        index = getPrev(true);\n      }\n    } else {\n      index = isLoop ? control : clamp(control, 0, getEnd());\n    }\n\n    return index;\n  }\n\n  function getNext(destination) {\n    return getAdjacent(false, destination);\n  }\n\n  function getPrev(destination) {\n    return getAdjacent(true, destination);\n  }\n\n  function getAdjacent(prev, destination) {\n    const number = perMove || (hasFocus() ? 1 : perPage);\n    const dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex);\n\n    if (dest === -1 && isSlide) {\n      if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {\n        return prev ? 0 : getEnd();\n      }\n    }\n\n    return destination ? dest : loop(dest);\n  }\n\n  function computeDestIndex(dest, from, incremental) {\n    if (isEnough()) {\n      const end = getEnd();\n\n      if (dest < 0 || dest > end) {\n        if (between(0, dest, from, true) || between(end, from, dest, true)) {\n          dest = toIndex(toPage(dest));\n        } else {\n          if (isLoop) {\n            dest = perMove || hasFocus() ? dest : dest < 0 ? -(slideCount % perPage || perPage) : slideCount;\n          } else if (options.rewind) {\n            dest = dest < 0 ? end : 0;\n          } else {\n            dest = -1;\n          }\n        }\n      } else {\n        if (!incremental && dest !== from) {\n          dest = perMove ? dest : toIndex(toPage(from) + (dest < from ? -1 : 1));\n        }\n      }\n    } else {\n      dest = -1;\n    }\n\n    return dest;\n  }\n\n  function getEnd() {\n    let end = slideCount - perPage;\n\n    if (hasFocus() || isLoop && perMove) {\n      end = slideCount - 1;\n    }\n\n    return max(end, 0);\n  }\n\n  function loop(index) {\n    if (isLoop) {\n      return isEnough() ? index % slideCount + (index < 0 ? slideCount : 0) : -1;\n    }\n\n    return index;\n  }\n\n  function toIndex(page) {\n    return clamp(hasFocus() ? page : perPage * page, 0, getEnd());\n  }\n\n  function toPage(index) {\n    if (!hasFocus()) {\n      index = between(index, slideCount - perPage, slideCount - 1) ? slideCount - 1 : index;\n      index = floor(index / perPage);\n    }\n\n    return index;\n  }\n\n  function toDest(destination) {\n    const closest = Move.toIndex(destination);\n    return isSlide ? clamp(closest, 0, getEnd()) : closest;\n  }\n\n  function setIndex(index) {\n    if (index !== currIndex) {\n      prevIndex = currIndex;\n      currIndex = index;\n    }\n  }\n\n  function getIndex(prev) {\n    return prev ? prevIndex : currIndex;\n  }\n\n  function hasFocus() {\n    return !isUndefined(options.focus) || options.isNavigation;\n  }\n\n  return {\n    mount,\n    go,\n    scroll,\n    getNext,\n    getPrev,\n    getAdjacent,\n    getEnd,\n    setIndex,\n    getIndex,\n    toIndex,\n    toPage,\n    toDest,\n    hasFocus\n  };\n}\n\nconst XML_NAME_SPACE = \"http://www.w3.org/2000/svg\";\nconst PATH = \"m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z\";\nconst SIZE = 40;\n\nfunction Arrows(Splide2, Components2, options) {\n  const {\n    on,\n    bind,\n    emit\n  } = EventInterface(Splide2);\n  const {\n    classes,\n    i18n\n  } = options;\n  const {\n    Elements,\n    Controller\n  } = Components2;\n  let wrapper = Elements.arrows;\n  let prev = Elements.prev;\n  let next = Elements.next;\n  let created;\n  const arrows = {};\n\n  function mount() {\n    init();\n    on(EVENT_UPDATED, init);\n  }\n\n  function init() {\n    if (options.arrows) {\n      if (!prev || !next) {\n        createArrows();\n      }\n    }\n\n    if (prev && next) {\n      if (!arrows.prev) {\n        const {\n          id\n        } = Elements.track;\n        setAttribute(prev, ARIA_CONTROLS, id);\n        setAttribute(next, ARIA_CONTROLS, id);\n        arrows.prev = prev;\n        arrows.next = next;\n        listen();\n        emit(EVENT_ARROWS_MOUNTED, prev, next);\n      } else {\n        display(wrapper, options.arrows === false ? \"none\" : \"\");\n      }\n    }\n  }\n\n  function destroy() {\n    if (created) {\n      remove(wrapper);\n    } else {\n      removeAttribute(prev, ALL_ATTRIBUTES);\n      removeAttribute(next, ALL_ATTRIBUTES);\n    }\n  }\n\n  function listen() {\n    const {\n      go\n    } = Controller;\n    on([EVENT_MOUNTED, EVENT_MOVED, EVENT_UPDATED, EVENT_REFRESH, EVENT_SCROLLED], update);\n    bind(next, \"click\", () => {\n      go(\">\", true);\n    });\n    bind(prev, \"click\", () => {\n      go(\"<\", true);\n    });\n  }\n\n  function createArrows() {\n    wrapper = create(\"div\", classes.arrows);\n    prev = createArrow(true);\n    next = createArrow(false);\n    created = true;\n    append(wrapper, [prev, next]);\n    before(wrapper, child(options.arrows === \"slider\" && Elements.slider || Splide2.root));\n  }\n\n  function createArrow(prev2) {\n    const arrow = `<button class=\"${classes.arrow} ${prev2 ? classes.prev : classes.next}\" type=\"button\"><svg xmlns=\"${XML_NAME_SPACE}\" viewBox=\"0 0 ${SIZE} ${SIZE}\" width=\"${SIZE}\" height=\"${SIZE}\"><path d=\"${options.arrowPath || PATH}\" />`;\n    return parseHtml(arrow);\n  }\n\n  function update() {\n    const index = Splide2.index;\n    const prevIndex = Controller.getPrev();\n    const nextIndex = Controller.getNext();\n    const prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n    const nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n    prev.disabled = prevIndex < 0;\n    next.disabled = nextIndex < 0;\n    setAttribute(prev, ARIA_LABEL, prevLabel);\n    setAttribute(next, ARIA_LABEL, nextLabel);\n    emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);\n  }\n\n  return {\n    arrows,\n    mount,\n    destroy\n  };\n}\n\nconst INTERVAL_DATA_ATTRIBUTE = `${DATA_ATTRIBUTE}-interval`;\n\nfunction Autoplay(Splide2, Components2, options) {\n  const {\n    on,\n    bind,\n    emit\n  } = EventInterface(Splide2);\n  const interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, \">\"), update);\n  const {\n    isPaused\n  } = interval;\n  const {\n    Elements\n  } = Components2;\n  let hovered;\n  let focused;\n  let paused;\n\n  function mount() {\n    const {\n      autoplay\n    } = options;\n\n    if (autoplay) {\n      initButton(true);\n      initButton(false);\n      listen();\n\n      if (autoplay !== \"pause\") {\n        play();\n      }\n    }\n  }\n\n  function initButton(forPause) {\n    const prop = forPause ? \"pause\" : \"play\";\n    const button = Elements[prop];\n\n    if (button) {\n      setAttribute(button, ARIA_CONTROLS, Elements.track.id);\n      setAttribute(button, ARIA_LABEL, options.i18n[prop]);\n      bind(button, \"click\", forPause ? pause : play);\n    }\n  }\n\n  function listen() {\n    const {\n      root\n    } = Elements;\n\n    if (options.pauseOnHover) {\n      bind(root, \"mouseenter mouseleave\", e => {\n        hovered = e.type === \"mouseenter\";\n        autoToggle();\n      });\n    }\n\n    if (options.pauseOnFocus) {\n      bind(root, \"focusin focusout\", e => {\n        focused = e.type === \"focusin\";\n        autoToggle();\n      });\n    }\n\n    on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);\n    on(EVENT_MOVE, updateInterval);\n  }\n\n  function play() {\n    if (isPaused() && Components2.Slides.isEnough()) {\n      interval.start(!options.resetProgress);\n      focused = hovered = paused = false;\n      emit(EVENT_AUTOPLAY_PLAY);\n    }\n  }\n\n  function pause() {\n    let manual = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    if (!isPaused()) {\n      interval.pause();\n      emit(EVENT_AUTOPLAY_PAUSE);\n    }\n\n    paused = manual;\n  }\n\n  function autoToggle() {\n    if (!paused) {\n      if (!hovered && !focused) {\n        play();\n      } else {\n        pause(false);\n      }\n    }\n  }\n\n  function update(rate) {\n    const {\n      bar\n    } = Elements;\n    bar && style(bar, \"width\", `${rate * 100}%`);\n    emit(EVENT_AUTOPLAY_PLAYING, rate);\n  }\n\n  function updateInterval() {\n    const Slide = Components2.Slides.getAt(Splide2.index);\n    interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);\n  }\n\n  return {\n    mount,\n    destroy: interval.cancel,\n    play,\n    pause,\n    isPaused\n  };\n}\n\nfunction Cover(Splide2, Components2, options) {\n  const {\n    on\n  } = EventInterface(Splide2);\n\n  function mount() {\n    if (options.cover) {\n      on(EVENT_LAZYLOAD_LOADED, (img, Slide) => {\n        toggle(true, img, Slide);\n      });\n      on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply.bind(null, true));\n    }\n  }\n\n  function destroy() {\n    apply(false);\n  }\n\n  function apply(cover) {\n    Components2.Slides.forEach(Slide => {\n      const img = child(Slide.container || Slide.slide, \"img\");\n\n      if (img && img.src) {\n        toggle(cover, img, Slide);\n      }\n    });\n  }\n\n  function toggle(cover, img, Slide) {\n    Slide.style(\"background\", cover ? `center/cover no-repeat url(\"${img.src}\")` : \"\", true);\n    display(img, cover ? \"none\" : \"\");\n  }\n\n  return {\n    mount,\n    destroy\n  };\n}\n\nconst BOUNCE_DIFF_THRESHOLD = 10;\nconst BOUNCE_DURATION = 600;\nconst FRICTION_FACTOR = 0.6;\nconst BASE_VELOCITY = 1.5;\nconst MIN_DURATION = 800;\n\nfunction Scroll(Splide2, Components2, options) {\n  const {\n    on,\n    emit\n  } = EventInterface(Splide2);\n  const {\n    Move\n  } = Components2;\n  const {\n    getPosition,\n    getLimit,\n    exceededLimit\n  } = Move;\n  let interval;\n  let scrollCallback;\n\n  function mount() {\n    on(EVENT_MOVE, clear);\n    on([EVENT_UPDATED, EVENT_REFRESH], cancel);\n  }\n\n  function scroll(destination, duration, callback, suppressConstraint) {\n    const start = getPosition();\n    let friction = 1;\n    duration = duration || computeDuration(abs(destination - start));\n    scrollCallback = callback;\n    clear();\n    interval = RequestInterval(duration, onScrolled, rate => {\n      const position = getPosition();\n      const target = start + (destination - start) * easing(rate);\n      const diff = (target - getPosition()) * friction;\n      Move.translate(position + diff);\n\n      if (Splide2.is(SLIDE) && !suppressConstraint && exceededLimit()) {\n        friction *= FRICTION_FACTOR;\n\n        if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {\n          bounce(exceededLimit(false));\n        }\n      }\n    }, 1);\n    emit(EVENT_SCROLL);\n    interval.start();\n  }\n\n  function bounce(backwards) {\n    scroll(getLimit(!backwards), BOUNCE_DURATION, null, true);\n  }\n\n  function onScrolled() {\n    const position = getPosition();\n    const index = Move.toIndex(position);\n\n    if (!between(index, 0, Splide2.length - 1)) {\n      Move.translate(Move.shift(position, index > 0), true);\n    }\n\n    scrollCallback && scrollCallback();\n    emit(EVENT_SCROLLED);\n  }\n\n  function computeDuration(distance) {\n    return max(distance / BASE_VELOCITY, MIN_DURATION);\n  }\n\n  function clear() {\n    if (interval) {\n      interval.cancel();\n    }\n  }\n\n  function cancel() {\n    if (interval && !interval.isPaused()) {\n      clear();\n      onScrolled();\n    }\n  }\n\n  function easing(t) {\n    const {\n      easingFunc\n    } = options;\n    return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);\n  }\n\n  return {\n    mount,\n    destroy: clear,\n    scroll,\n    cancel\n  };\n}\n\nconst SCROLL_LISTENER_OPTIONS = {\n  passive: false,\n  capture: true\n};\nconst FRICTION = 5;\nconst LOG_INTERVAL = 200;\nconst POINTER_DOWN_EVENTS = \"touchstart mousedown\";\nconst POINTER_MOVE_EVENTS = \"touchmove mousemove\";\nconst POINTER_UP_EVENTS = \"touchend touchcancel mouseup\";\n\nfunction Drag(Splide2, Components2, options) {\n  const {\n    on,\n    emit,\n    bind,\n    unbind\n  } = EventInterface(Splide2);\n  const {\n    Move,\n    Scroll,\n    Controller\n  } = Components2;\n  const {\n    track\n  } = Components2.Elements;\n  const {\n    resolve,\n    orient\n  } = Components2.Direction;\n  const {\n    getPosition,\n    exceededLimit\n  } = Move;\n  let basePosition;\n  let baseEvent;\n  let prevBaseEvent;\n  let lastEvent;\n  let isFree;\n  let dragging;\n  let hasExceeded = false;\n  let clickPrevented;\n  let disabled;\n  let target;\n\n  function mount() {\n    bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);\n    bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);\n    bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);\n    bind(track, \"click\", onClick, {\n      capture: true\n    });\n    bind(track, \"dragstart\", prevent);\n    on([EVENT_MOUNTED, EVENT_UPDATED], init);\n  }\n\n  function init() {\n    const {\n      drag\n    } = options;\n    disable(!drag);\n    isFree = drag === \"free\";\n  }\n\n  function onPointerDown(e) {\n    if (!disabled) {\n      const {\n        noDrag\n      } = options;\n      const isTouch = isTouchEvent(e);\n      const isDraggable = !noDrag || !matches(e.target, noDrag);\n      clickPrevented = false;\n\n      if (isDraggable && (isTouch || !e.button)) {\n        if (!Move.isBusy()) {\n          target = isTouch ? track : window;\n          prevBaseEvent = null;\n          lastEvent = null;\n          bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);\n          bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);\n          Move.cancel();\n          Scroll.cancel();\n          save(e);\n        } else {\n          prevent(e, true);\n        }\n      }\n    }\n  }\n\n  function onPointerMove(e) {\n    if (!lastEvent) {\n      emit(EVENT_DRAG);\n    }\n\n    lastEvent = e;\n\n    if (e.cancelable) {\n      const diff = coordOf(e) - coordOf(baseEvent);\n\n      if (dragging) {\n        Move.translate(basePosition + constrain(diff));\n        const expired = timeOf(e) - timeOf(baseEvent) > LOG_INTERVAL;\n        const exceeded = hasExceeded !== (hasExceeded = exceededLimit());\n\n        if (expired || exceeded) {\n          save(e);\n        }\n\n        emit(EVENT_DRAGGING);\n        clickPrevented = true;\n        prevent(e);\n      } else {\n        let {\n          dragMinThreshold: thresholds\n        } = options;\n        thresholds = isObject(thresholds) ? thresholds : {\n          mouse: 0,\n          touch: +thresholds || 10\n        };\n        dragging = abs(diff) > (isTouchEvent(e) ? thresholds.touch : thresholds.mouse);\n\n        if (isSliderDirection()) {\n          prevent(e);\n        }\n      }\n    }\n  }\n\n  function onPointerUp(e) {\n    unbind(target, POINTER_MOVE_EVENTS, onPointerMove);\n    unbind(target, POINTER_UP_EVENTS, onPointerUp);\n    const {\n      index\n    } = Splide2;\n\n    if (lastEvent) {\n      if (dragging || e.cancelable && isSliderDirection()) {\n        const velocity = computeVelocity(e);\n        const destination = computeDestination(velocity);\n\n        if (isFree) {\n          Controller.scroll(destination);\n        } else if (Splide2.is(FADE)) {\n          Controller.go(index + orient(sign(velocity)));\n        } else {\n          Controller.go(Controller.toDest(destination), true);\n        }\n\n        prevent(e);\n      }\n\n      emit(EVENT_DRAGGED);\n    } else {\n      if (!isFree && getPosition() !== Move.toPosition(index)) {\n        Controller.go(index, true);\n      }\n    }\n\n    dragging = false;\n  }\n\n  function save(e) {\n    prevBaseEvent = baseEvent;\n    baseEvent = e;\n    basePosition = getPosition();\n  }\n\n  function onClick(e) {\n    if (!disabled && clickPrevented) {\n      prevent(e, true);\n    }\n  }\n\n  function isSliderDirection() {\n    const diffX = abs(coordOf(lastEvent) - coordOf(baseEvent));\n    const diffY = abs(coordOf(lastEvent, true) - coordOf(baseEvent, true));\n    return diffX > diffY;\n  }\n\n  function computeVelocity(e) {\n    if (Splide2.is(LOOP) || !hasExceeded) {\n      const base = baseEvent === lastEvent && prevBaseEvent || baseEvent;\n      const diffCoord = coordOf(lastEvent) - coordOf(base);\n      const diffTime = timeOf(e) - timeOf(base);\n      const isFlick = timeOf(e) - timeOf(lastEvent) < LOG_INTERVAL;\n\n      if (diffTime && isFlick) {\n        return diffCoord / diffTime;\n      }\n    }\n\n    return 0;\n  }\n\n  function computeDestination(velocity) {\n    return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));\n  }\n\n  function coordOf(e, orthogonal) {\n    return (isTouchEvent(e) ? e.touches[0] : e)[`page${resolve(orthogonal ? \"Y\" : \"X\")}`];\n  }\n\n  function timeOf(e) {\n    return e.timeStamp;\n  }\n\n  function constrain(diff) {\n    return diff / (hasExceeded && Splide2.is(SLIDE) ? FRICTION : 1);\n  }\n\n  function isTouchEvent(e) {\n    return typeof TouchEvent !== \"undefined\" && e instanceof TouchEvent;\n  }\n\n  function isDragging() {\n    return dragging;\n  }\n\n  function disable(value) {\n    disabled = value;\n  }\n\n  return {\n    mount,\n    disable,\n    isDragging\n  };\n}\n\nconst IE_ARROW_KEYS = [\"Left\", \"Right\", \"Up\", \"Down\"];\nconst KEYBOARD_EVENT = \"keydown\";\n\nfunction Keyboard(Splide2, Components2, options) {\n  const {\n    on,\n    bind,\n    unbind\n  } = EventInterface(Splide2);\n  const {\n    root\n  } = Splide2;\n  const {\n    resolve\n  } = Components2.Direction;\n  let target;\n  let disabled;\n\n  function mount() {\n    init();\n    on(EVENT_UPDATED, onUpdated);\n    on(EVENT_MOVE, onMove);\n  }\n\n  function init() {\n    const {\n      keyboard\n    } = options;\n\n    if (keyboard) {\n      if (keyboard === \"focused\") {\n        target = root;\n        setAttribute(root, TAB_INDEX, 0);\n      } else {\n        target = window;\n      }\n\n      bind(target, KEYBOARD_EVENT, onKeydown);\n    }\n  }\n\n  function destroy() {\n    unbind(target, KEYBOARD_EVENT);\n\n    if (isHTMLElement(target)) {\n      removeAttribute(target, TAB_INDEX);\n    }\n  }\n\n  function disable(value) {\n    disabled = value;\n  }\n\n  function onMove() {\n    const _disabled = disabled;\n    disabled = true;\n    nextTick(() => {\n      disabled = _disabled;\n    });\n  }\n\n  function onUpdated() {\n    destroy();\n    init();\n  }\n\n  function onKeydown(e) {\n    if (!disabled) {\n      const {\n        key\n      } = e;\n      const normalizedKey = includes(IE_ARROW_KEYS, key) ? `Arrow${key}` : key;\n\n      if (normalizedKey === resolve(\"ArrowLeft\")) {\n        Splide2.go(\"<\");\n      } else if (normalizedKey === resolve(\"ArrowRight\")) {\n        Splide2.go(\">\");\n      }\n    }\n  }\n\n  return {\n    mount,\n    destroy,\n    disable\n  };\n}\n\nconst SRC_DATA_ATTRIBUTE = `${DATA_ATTRIBUTE}-lazy`;\nconst SRCSET_DATA_ATTRIBUTE = `${SRC_DATA_ATTRIBUTE}-srcset`;\nconst IMAGE_SELECTOR = `[${SRC_DATA_ATTRIBUTE}], [${SRCSET_DATA_ATTRIBUTE}]`;\n\nfunction LazyLoad(Splide2, Components2, options) {\n  const {\n    on,\n    off,\n    bind,\n    emit\n  } = EventInterface(Splide2);\n  const isSequential = options.lazyLoad === \"sequential\";\n  let images = [];\n  let index = 0;\n\n  function mount() {\n    if (options.lazyLoad) {\n      init();\n      on(EVENT_REFRESH, refresh);\n\n      if (!isSequential) {\n        on([EVENT_MOUNTED, EVENT_REFRESH, EVENT_MOVED, EVENT_SCROLLED], observe);\n      }\n    }\n  }\n\n  function refresh() {\n    destroy();\n    init();\n  }\n\n  function init() {\n    Components2.Slides.forEach(_Slide => {\n      queryAll(_Slide.slide, IMAGE_SELECTOR).forEach(_img => {\n        const src = getAttribute(_img, SRC_DATA_ATTRIBUTE);\n        const srcset = getAttribute(_img, SRCSET_DATA_ATTRIBUTE);\n\n        if (src !== _img.src || srcset !== _img.srcset) {\n          const className = options.classes.spinner;\n          const parent = _img.parentElement;\n\n          const _spinner = child(parent, `.${className}`) || create(\"span\", className, parent);\n\n          setAttribute(_spinner, ROLE, \"presentation\");\n          images.push({\n            _img,\n            _Slide,\n            src,\n            srcset,\n            _spinner\n          });\n          !_img.src && display(_img, \"none\");\n        }\n      });\n    });\n\n    if (isSequential) {\n      loadNext();\n    }\n  }\n\n  function destroy() {\n    index = 0;\n    images = [];\n  }\n\n  function observe() {\n    images = images.filter(data => {\n      const distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;\n\n      if (data._Slide.isWithin(Splide2.index, distance)) {\n        return load(data);\n      }\n\n      return true;\n    });\n\n    if (!images.length) {\n      off(EVENT_MOVED);\n    }\n  }\n\n  function load(data) {\n    const {\n      _img\n    } = data;\n    addClass(data._Slide.slide, CLASS_LOADING);\n    bind(_img, \"load error\", e => {\n      onLoad(data, e.type === \"error\");\n    });\n    [\"src\", \"srcset\"].forEach(name => {\n      if (data[name]) {\n        setAttribute(_img, name, data[name]);\n        removeAttribute(_img, name === \"src\" ? SRC_DATA_ATTRIBUTE : SRCSET_DATA_ATTRIBUTE);\n      }\n    });\n  }\n\n  function onLoad(data, error) {\n    const {\n      _Slide\n    } = data;\n    removeClass(_Slide.slide, CLASS_LOADING);\n\n    if (!error) {\n      remove(data._spinner);\n      display(data._img, \"\");\n      emit(EVENT_LAZYLOAD_LOADED, data._img, _Slide);\n      emit(EVENT_RESIZE);\n    }\n\n    if (isSequential) {\n      loadNext();\n    }\n  }\n\n  function loadNext() {\n    if (index < images.length) {\n      load(images[index++]);\n    }\n  }\n\n  return {\n    mount,\n    destroy\n  };\n}\n\nfunction Pagination(Splide2, Components2, options) {\n  const {\n    on,\n    emit,\n    bind,\n    unbind\n  } = EventInterface(Splide2);\n  const {\n    Slides,\n    Elements,\n    Controller\n  } = Components2;\n  const {\n    hasFocus,\n    getIndex\n  } = Controller;\n  const items = [];\n  let list;\n\n  function mount() {\n    init();\n    on([EVENT_UPDATED, EVENT_REFRESH], init);\n    on([EVENT_MOVE, EVENT_SCROLLED], update);\n  }\n\n  function init() {\n    destroy();\n\n    if (options.pagination && Slides.isEnough()) {\n      createPagination();\n      emit(EVENT_PAGINATION_MOUNTED, {\n        list,\n        items\n      }, getAt(Splide2.index));\n      update();\n    }\n  }\n\n  function destroy() {\n    if (list) {\n      remove(list);\n      items.forEach(item => {\n        unbind(item.button, \"click\");\n      });\n      empty(items);\n      list = null;\n    }\n  }\n\n  function createPagination() {\n    const {\n      length\n    } = Splide2;\n    const {\n      classes,\n      i18n,\n      perPage\n    } = options;\n    const parent = options.pagination === \"slider\" && Elements.slider || Elements.root;\n    const max = hasFocus() ? length : ceil(length / perPage);\n    list = create(\"ul\", classes.pagination, parent);\n\n    for (let i = 0; i < max; i++) {\n      const li = create(\"li\", null, list);\n      const button = create(\"button\", {\n        class: classes.page,\n        type: \"button\"\n      }, li);\n      const controls = Slides.getIn(i).map(Slide => Slide.slide.id);\n      const text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;\n      bind(button, \"click\", onClick.bind(null, i));\n      setAttribute(button, ARIA_CONTROLS, controls.join(\" \"));\n      setAttribute(button, ARIA_LABEL, format(text, i + 1));\n      items.push({\n        li,\n        button,\n        page: i\n      });\n    }\n  }\n\n  function onClick(page) {\n    Controller.go(`>${page}`, true, () => {\n      const Slide = Slides.getAt(Controller.toIndex(page));\n      Slide && focus(Slide.slide);\n    });\n  }\n\n  function getAt(index) {\n    return items[Controller.toPage(index)];\n  }\n\n  function update() {\n    const prev = getAt(getIndex(true));\n    const curr = getAt(getIndex());\n\n    if (prev) {\n      removeClass(prev.button, CLASS_ACTIVE);\n      removeAttribute(prev.button, ARIA_CURRENT);\n    }\n\n    if (curr) {\n      addClass(curr.button, CLASS_ACTIVE);\n      setAttribute(curr.button, ARIA_CURRENT, true);\n    }\n\n    emit(EVENT_PAGINATION_UPDATED, {\n      list,\n      items\n    }, prev, curr);\n  }\n\n  return {\n    items,\n    mount,\n    destroy,\n    getAt,\n    update\n  };\n}\n\nconst TRIGGER_KEYS = [\" \", \"Enter\", \"Spacebar\"];\n\nfunction Sync(Splide2, Components2, options) {\n  const {\n    list\n  } = Components2.Elements;\n  const events = [];\n\n  function mount() {\n    Splide2.splides.forEach(target => {\n      !target.isParent && sync(target.splide);\n    });\n\n    if (options.isNavigation) {\n      navigate();\n    }\n  }\n\n  function destroy() {\n    removeAttribute(list, ALL_ATTRIBUTES);\n    events.forEach(event => {\n      event.destroy();\n    });\n    empty(events);\n  }\n\n  function remount() {\n    destroy();\n    mount();\n  }\n\n  function sync(splide) {\n    [Splide2, splide].forEach(instance => {\n      const event = EventInterface(instance);\n      const target = instance === Splide2 ? splide : Splide2;\n      event.on(EVENT_MOVE, (index, prev, dest) => {\n        target.go(target.is(LOOP) ? dest : index);\n      });\n      events.push(event);\n    });\n  }\n\n  function navigate() {\n    const event = EventInterface(Splide2);\n    const {\n      on\n    } = event;\n    on(EVENT_CLICK, onClick);\n    on(EVENT_SLIDE_KEYDOWN, onKeydown);\n    on([EVENT_MOUNTED, EVENT_UPDATED], update);\n    setAttribute(list, ROLE, \"menu\");\n    events.push(event);\n    event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);\n  }\n\n  function update() {\n    setAttribute(list, ARIA_ORIENTATION, options.direction !== TTB ? \"horizontal\" : null);\n  }\n\n  function onClick(Slide) {\n    Splide2.go(Slide.index);\n  }\n\n  function onKeydown(Slide, e) {\n    if (includes(TRIGGER_KEYS, e.key)) {\n      onClick(Slide);\n      prevent(e);\n    }\n  }\n\n  return {\n    mount,\n    destroy,\n    remount\n  };\n}\n\nfunction Wheel(Splide2, Components2, options) {\n  const {\n    bind\n  } = EventInterface(Splide2);\n\n  function mount() {\n    if (options.wheel) {\n      bind(Components2.Elements.track, \"wheel\", onWheel, SCROLL_LISTENER_OPTIONS);\n    }\n  }\n\n  function onWheel(e) {\n    if (e.cancelable) {\n      const {\n        deltaY\n      } = e;\n\n      if (deltaY) {\n        const backwards = deltaY < 0;\n        Splide2.go(backwards ? \"<\" : \">\");\n        shouldPrevent(backwards) && prevent(e);\n      }\n    }\n  }\n\n  function shouldPrevent(backwards) {\n    return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;\n  }\n\n  return {\n    mount\n  };\n}\n\nvar ComponentConstructors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Options: Options,\n  Direction: Direction,\n  Elements: Elements,\n  Slides: Slides,\n  Layout: Layout,\n  Clones: Clones,\n  Move: Move,\n  Controller: Controller,\n  Arrows: Arrows,\n  Autoplay: Autoplay,\n  Cover: Cover,\n  Scroll: Scroll,\n  Drag: Drag,\n  Keyboard: Keyboard,\n  LazyLoad: LazyLoad,\n  Pagination: Pagination,\n  Sync: Sync,\n  Wheel: Wheel\n});\nconst I18N = {\n  prev: \"Previous slide\",\n  next: \"Next slide\",\n  first: \"Go to first slide\",\n  last: \"Go to last slide\",\n  slideX: \"Go to slide %s\",\n  pageX: \"Go to page %s\",\n  play: \"Start autoplay\",\n  pause: \"Pause autoplay\"\n};\nconst DEFAULTS = {\n  type: \"slide\",\n  speed: 400,\n  waitForTransition: true,\n  perPage: 1,\n  cloneStatus: true,\n  arrows: true,\n  pagination: true,\n  interval: 5e3,\n  pauseOnHover: true,\n  pauseOnFocus: true,\n  resetProgress: true,\n  keyboard: true,\n  easing: \"cubic-bezier(0.25, 1, 0.5, 1)\",\n  drag: true,\n  direction: \"ltr\",\n  slideFocus: true,\n  trimSpace: true,\n  focusableNodes: \"a, button, textarea, input, select, iframe\",\n  classes: CLASSES,\n  i18n: I18N\n};\n\nfunction Fade(Splide2, Components2, options) {\n  const {\n    on\n  } = EventInterface(Splide2);\n\n  function mount() {\n    on([EVENT_MOUNTED, EVENT_REFRESH], () => {\n      nextTick(() => {\n        Components2.Slides.style(\"transition\", `opacity ${options.speed}ms ${options.easing}`);\n      });\n    });\n  }\n\n  function start(index, done) {\n    const {\n      track\n    } = Components2.Elements;\n    style(track, \"height\", unit(rect(track).height));\n    nextTick(() => {\n      done();\n      style(track, \"height\", \"\");\n    });\n  }\n\n  return {\n    mount,\n    start,\n    cancel: noop\n  };\n}\n\nfunction Slide(Splide2, Components2, options) {\n  const {\n    bind\n  } = EventInterface(Splide2);\n  const {\n    Move,\n    Controller\n  } = Components2;\n  const {\n    list\n  } = Components2.Elements;\n  let endCallback;\n\n  function mount() {\n    bind(list, \"transitionend\", e => {\n      if (e.target === list && endCallback) {\n        cancel();\n        endCallback();\n      }\n    });\n  }\n\n  function start(index, done) {\n    const destination = Move.toPosition(index, true);\n    const position = Move.getPosition();\n    const speed = getSpeed(index);\n\n    if (abs(destination - position) >= 1 && speed >= 1) {\n      apply(`transform ${speed}ms ${options.easing}`);\n      Move.translate(destination, true);\n      endCallback = done;\n    } else {\n      Move.jump(index);\n      done();\n    }\n  }\n\n  function cancel() {\n    apply(\"\");\n  }\n\n  function getSpeed(index) {\n    const {\n      rewindSpeed\n    } = options;\n\n    if (Splide2.is(SLIDE) && rewindSpeed) {\n      const prev = Controller.getIndex(true);\n      const end = Controller.getEnd();\n\n      if (prev === 0 && index >= end || prev >= end && index === 0) {\n        return rewindSpeed;\n      }\n    }\n\n    return options.speed;\n  }\n\n  function apply(transition) {\n    style(list, \"transition\", transition);\n  }\n\n  return {\n    mount,\n    start,\n    cancel\n  };\n}\n\nconst _Splide = class {\n  constructor(target, options) {\n    this.event = EventBus();\n    this.Components = {};\n    this.state = State(CREATED);\n    this.splides = [];\n    this._options = {};\n    this._Extensions = {};\n    const root = isString(target) ? query(document, target) : target;\n    assert(root, `${root} is invalid.`);\n    this.root = root;\n    merge(DEFAULTS, _Splide.defaults);\n    merge(merge(this._options, DEFAULTS), options || {});\n  }\n\n  mount(Extensions, Transition) {\n    const {\n      state,\n      Components: Components2\n    } = this;\n    assert(state.is([CREATED, DESTROYED]), \"Already mounted!\");\n    state.set(CREATED);\n    this._Components = Components2;\n    this._Transition = Transition || this._Transition || (this.is(FADE) ? Fade : Slide);\n    this._Extensions = Extensions || this._Extensions;\n    const Constructors = assign({}, ComponentConstructors, this._Extensions, {\n      Transition: this._Transition\n    });\n    forOwn(Constructors, (Component, key) => {\n      const component = Component(this, Components2, this._options);\n      Components2[key] = component;\n      component.setup && component.setup();\n    });\n    forOwn(Components2, component => {\n      component.mount && component.mount();\n    });\n    this.emit(EVENT_MOUNTED);\n    addClass(this.root, CLASS_INITIALIZED);\n    state.set(IDLE);\n    this.emit(EVENT_READY);\n    return this;\n  }\n\n  sync(splide) {\n    this.splides.push({\n      splide\n    });\n    splide.splides.push({\n      splide: this,\n      isParent: true\n    });\n\n    if (this.state.is(IDLE)) {\n      this._Components.Sync.remount();\n\n      splide.Components.Sync.remount();\n    }\n\n    return this;\n  }\n\n  go(control) {\n    this._Components.Controller.go(control);\n\n    return this;\n  }\n\n  on(events, callback) {\n    this.event.on(events, callback, null, DEFAULT_USER_EVENT_PRIORITY);\n    return this;\n  }\n\n  off(events) {\n    this.event.off(events);\n    return this;\n  }\n\n  emit(event) {\n    this.event.emit(event, ...slice(arguments, 1));\n    return this;\n  }\n\n  add(slides, index) {\n    this._Components.Slides.add(slides, index);\n\n    return this;\n  }\n\n  remove(matcher) {\n    this._Components.Slides.remove(matcher);\n\n    return this;\n  }\n\n  is(type) {\n    return this._options.type === type;\n  }\n\n  refresh() {\n    this.emit(EVENT_REFRESH);\n    return this;\n  }\n\n  destroy() {\n    let completely = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const {\n      event,\n      state\n    } = this;\n\n    if (state.is(CREATED)) {\n      event.on(EVENT_READY, this.destroy.bind(this, completely), this);\n    } else {\n      forOwn(this._Components, component => {\n        component.destroy && component.destroy(completely);\n      }, true);\n      event.emit(EVENT_DESTROY);\n      event.destroy();\n      completely && empty(this.splides);\n      state.set(DESTROYED);\n    }\n\n    return this;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    const {\n      _options\n    } = this;\n    merge(_options, options);\n\n    if (!this.state.is(CREATED)) {\n      this.emit(EVENT_UPDATED, _options);\n    }\n  }\n\n  get length() {\n    return this._Components.Slides.getLength(true);\n  }\n\n  get index() {\n    return this._Components.Controller.getIndex();\n  }\n\n};\n\nlet Splide = _Splide;\nSplide.defaults = {};\nSplide.STATES = STATES;\nconst CLASS_RENDERED = \"is-rendered\";\nconst RENDERER_DEFAULT_CONFIG = {\n  listTag: \"ul\",\n  slideTag: \"li\"\n};\n\nclass Style {\n  constructor(id, options) {\n    this.styles = {};\n    this.id = id;\n    this.options = options;\n  }\n\n  rule(selector, prop, value, breakpoint) {\n    breakpoint = breakpoint || \"default\";\n    const selectors = this.styles[breakpoint] = this.styles[breakpoint] || {};\n    const styles = selectors[selector] = selectors[selector] || {};\n    styles[prop] = value;\n  }\n\n  build() {\n    let css = \"\";\n\n    if (this.styles.default) {\n      css += this.buildSelectors(this.styles.default);\n    }\n\n    Object.keys(this.styles).sort((n, m) => this.options.mediaQuery === \"min\" ? +n - +m : +m - +n).forEach(breakpoint => {\n      if (breakpoint !== \"default\") {\n        css += `@media screen and (max-width: ${breakpoint}px) {`;\n        css += this.buildSelectors(this.styles[breakpoint]);\n        css += `}`;\n      }\n    });\n    return css;\n  }\n\n  buildSelectors(selectors) {\n    let css = \"\";\n    forOwn(selectors, (styles, selector) => {\n      selector = `#${this.id} ${selector}`.trim();\n      css += `${selector} {`;\n      forOwn(styles, (value, prop) => {\n        if (value || value === 0) {\n          css += `${prop}: ${value};`;\n        }\n      });\n      css += \"}\";\n    });\n    return css;\n  }\n\n}\n\nclass SplideRenderer {\n  constructor(contents, options, config, defaults) {\n    this.slides = [];\n    this.options = {};\n    this.breakpoints = [];\n    merge(DEFAULTS, defaults || {});\n    merge(merge(this.options, DEFAULTS), options || {});\n    this.contents = contents;\n    this.config = assign({}, RENDERER_DEFAULT_CONFIG, config || {});\n    this.id = this.config.id || uniqueId(\"splide\");\n    this.Style = new Style(this.id, this.options);\n    this.Direction = Direction(null, null, this.options);\n    assert(this.contents.length, \"Provide at least 1 content.\");\n    this.init();\n  }\n\n  static clean(splide) {\n    const {\n      on\n    } = EventInterface(splide);\n    const {\n      root\n    } = splide;\n    const clones = queryAll(root, `.${CLASS_CLONE}`);\n    on(EVENT_MOUNTED, () => {\n      remove(child(root, \"style\"));\n    });\n    remove(clones);\n  }\n\n  init() {\n    this.parseBreakpoints();\n    this.initSlides();\n    this.registerRootStyles();\n    this.registerTrackStyles();\n    this.registerSlideStyles();\n    this.registerListStyles();\n  }\n\n  initSlides() {\n    push(this.slides, this.contents.map((content, index) => {\n      content = isString(content) ? {\n        html: content\n      } : content;\n      content.styles = content.styles || {};\n      content.attrs = content.attrs || {};\n      this.cover(content);\n      const classes = `${this.options.classes.slide} ${index === 0 ? CLASS_ACTIVE : \"\"}`;\n      assign(content.attrs, {\n        class: `${classes} ${content.attrs.class || \"\"}`.trim(),\n        style: this.buildStyles(content.styles)\n      });\n      return content;\n    }));\n\n    if (this.isLoop()) {\n      this.generateClones(this.slides);\n    }\n  }\n\n  registerRootStyles() {\n    this.breakpoints.forEach(_ref => {\n      let [width, options] = _ref;\n      this.Style.rule(\" \", \"max-width\", unit(options.width), width);\n    });\n  }\n\n  registerTrackStyles() {\n    const {\n      Style: Style2\n    } = this;\n    const selector = `.${CLASS_TRACK}`;\n    this.breakpoints.forEach(_ref2 => {\n      let [width, options] = _ref2;\n      Style2.rule(selector, this.resolve(\"paddingLeft\"), this.cssPadding(options, false), width);\n      Style2.rule(selector, this.resolve(\"paddingRight\"), this.cssPadding(options, true), width);\n      Style2.rule(selector, \"height\", this.cssTrackHeight(options), width);\n    });\n  }\n\n  registerListStyles() {\n    const {\n      Style: Style2\n    } = this;\n    const selector = `.${CLASS_LIST}`;\n    this.breakpoints.forEach(_ref3 => {\n      let [width, options] = _ref3;\n      Style2.rule(selector, \"transform\", this.buildTranslate(options), width);\n\n      if (!this.cssSlideHeight(options)) {\n        Style2.rule(selector, \"aspect-ratio\", this.cssAspectRatio(options), width);\n      }\n    });\n  }\n\n  registerSlideStyles() {\n    const {\n      Style: Style2\n    } = this;\n    const selector = `.${CLASS_SLIDE}`;\n    this.breakpoints.forEach(_ref4 => {\n      let [width, options] = _ref4;\n      Style2.rule(selector, \"width\", this.cssSlideWidth(options), width);\n      Style2.rule(selector, \"height\", this.cssSlideHeight(options) || \"100%\", width);\n      Style2.rule(selector, this.resolve(\"marginRight\"), unit(options.gap) || \"0px\", width);\n      Style2.rule(`${selector} > img`, \"display\", options.cover ? \"none\" : \"inline\", width);\n    });\n  }\n\n  buildTranslate(options) {\n    const {\n      resolve,\n      orient\n    } = this.Direction;\n    const values = [];\n    values.push(this.cssOffsetClones(options));\n    values.push(this.cssOffsetGaps(options));\n\n    if (this.isCenter(options)) {\n      values.push(this.buildCssValue(orient(-50), \"%\"));\n      values.push(...this.cssOffsetCenter(options));\n    }\n\n    return values.filter(Boolean).map(value => `translate${resolve(\"X\")}(${value})`).join(\" \");\n  }\n\n  cssOffsetClones(options) {\n    const {\n      resolve,\n      orient\n    } = this.Direction;\n    const cloneCount = this.getCloneCount();\n\n    if (this.isFixedWidth(options)) {\n      const {\n        value,\n        unit: unit2\n      } = this.parseCssValue(options[resolve(\"fixedWidth\")]);\n      return this.buildCssValue(orient(value) * cloneCount, unit2);\n    }\n\n    const percent = 100 * cloneCount / options.perPage;\n    return `${orient(percent)}%`;\n  }\n\n  cssOffsetCenter(options) {\n    const {\n      resolve,\n      orient\n    } = this.Direction;\n\n    if (this.isFixedWidth(options)) {\n      const {\n        value,\n        unit: unit2\n      } = this.parseCssValue(options[resolve(\"fixedWidth\")]);\n      return [this.buildCssValue(orient(value / 2), unit2)];\n    }\n\n    const values = [];\n    const {\n      perPage,\n      gap\n    } = options;\n    values.push(`${orient(50 / perPage)}%`);\n\n    if (gap) {\n      const {\n        value,\n        unit: unit2\n      } = this.parseCssValue(gap);\n      const gapOffset = (value / perPage - value) / 2;\n      values.push(this.buildCssValue(orient(gapOffset), unit2));\n    }\n\n    return values;\n  }\n\n  cssOffsetGaps(options) {\n    const cloneCount = this.getCloneCount();\n\n    if (cloneCount && options.gap) {\n      const {\n        orient\n      } = this.Direction;\n      const {\n        value,\n        unit: unit2\n      } = this.parseCssValue(options.gap);\n\n      if (this.isFixedWidth(options)) {\n        return this.buildCssValue(orient(value * cloneCount), unit2);\n      }\n\n      const {\n        perPage\n      } = options;\n      const gaps = cloneCount / perPage;\n      return this.buildCssValue(orient(gaps * value), unit2);\n    }\n\n    return \"\";\n  }\n\n  resolve(prop) {\n    return camelToKebab(this.Direction.resolve(prop));\n  }\n\n  cssPadding(options, right) {\n    const {\n      padding\n    } = options;\n    const prop = this.Direction.resolve(right ? \"right\" : \"left\", true);\n    return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || \"0px\";\n  }\n\n  cssTrackHeight(options) {\n    let height = \"\";\n\n    if (this.isVertical()) {\n      height = this.cssHeight(options);\n      assert(height, '\"height\" is missing.');\n      height = `calc(${height} - ${this.cssPadding(options, false)} - ${this.cssPadding(options, true)})`;\n    }\n\n    return height;\n  }\n\n  cssHeight(options) {\n    return unit(options.height);\n  }\n\n  cssSlideWidth(options) {\n    return options.autoWidth ? \"\" : unit(options.fixedWidth) || (this.isVertical() ? \"\" : this.cssSlideSize(options));\n  }\n\n  cssSlideHeight(options) {\n    return unit(options.fixedHeight) || (this.isVertical() ? options.autoHeight ? \"\" : this.cssSlideSize(options) : this.cssHeight(options));\n  }\n\n  cssSlideSize(options) {\n    const gap = unit(options.gap);\n    return `calc((100%${gap && ` + ${gap}`})/${options.perPage || 1}${gap && ` - ${gap}`})`;\n  }\n\n  cssAspectRatio(options) {\n    const {\n      heightRatio\n    } = options;\n    return heightRatio ? `${1 / heightRatio}` : \"\";\n  }\n\n  buildCssValue(value, unit2) {\n    return `${value}${unit2}`;\n  }\n\n  parseCssValue(value) {\n    if (isString(value)) {\n      const number = parseFloat(value) || 0;\n      const unit2 = value.replace(/\\d*(\\.\\d*)?/, \"\") || \"px\";\n      return {\n        value: number,\n        unit: unit2\n      };\n    }\n\n    return {\n      value,\n      unit: \"px\"\n    };\n  }\n\n  parseBreakpoints() {\n    const {\n      breakpoints\n    } = this.options;\n    this.breakpoints.push([\"default\", this.options]);\n\n    if (breakpoints) {\n      forOwn(breakpoints, (options, width) => {\n        this.breakpoints.push([width, merge(merge({}, this.options), options)]);\n      });\n    }\n  }\n\n  isFixedWidth(options) {\n    return !!options[this.Direction.resolve(\"fixedWidth\")];\n  }\n\n  isLoop() {\n    return this.options.type === LOOP;\n  }\n\n  isCenter(options) {\n    if (options.focus === \"center\") {\n      if (this.isLoop()) {\n        return true;\n      }\n\n      if (this.options.type === SLIDE) {\n        return !this.options.trimSpace;\n      }\n    }\n\n    return false;\n  }\n\n  isVertical() {\n    return this.options.direction === TTB;\n  }\n\n  buildClasses() {\n    const {\n      options\n    } = this;\n    return [CLASS_ROOT, `${CLASS_ROOT}--${options.type}`, `${CLASS_ROOT}--${options.direction}`, options.drag && `${CLASS_ROOT}--draggable`, options.isNavigation && `${CLASS_ROOT}--nav`, CLASS_ACTIVE, !this.config.hidden && CLASS_RENDERED].filter(Boolean).join(\" \");\n  }\n\n  buildAttrs(attrs) {\n    let attr = \"\";\n    forOwn(attrs, (value, key) => {\n      attr += value ? ` ${camelToKebab(key)}=\"${value}\"` : \"\";\n    });\n    return attr.trim();\n  }\n\n  buildStyles(styles) {\n    let style = \"\";\n    forOwn(styles, (value, key) => {\n      style += ` ${camelToKebab(key)}:${value};`;\n    });\n    return style.trim();\n  }\n\n  renderSlides() {\n    const {\n      slideTag: tag\n    } = this.config;\n    return this.slides.map(content => {\n      return `<${tag} ${this.buildAttrs(content.attrs)}>${content.html || \"\"}</${tag}>`;\n    }).join(\"\");\n  }\n\n  cover(content) {\n    const {\n      styles,\n      html = \"\"\n    } = content;\n\n    if (this.options.cover && !this.options.lazyLoad) {\n      const src = html.match(/<img.*?src\\s*=\\s*(['\"])(.+?)\\1.*?>/);\n\n      if (src && src[2]) {\n        styles.background = `center/cover no-repeat url('${src[2]}')`;\n      }\n    }\n  }\n\n  generateClones(contents) {\n    const {\n      classes\n    } = this.options;\n    const count = this.getCloneCount();\n    const slides = contents.slice();\n\n    while (slides.length < count) {\n      push(slides, slides);\n    }\n\n    push(slides.slice(-count).reverse(), slides.slice(0, count)).forEach((content, index) => {\n      const attrs = assign({}, content.attrs, {\n        class: `${content.attrs.class} ${classes.clone}`\n      });\n      const clone = assign({}, content, {\n        attrs\n      });\n      index < count ? contents.unshift(clone) : contents.push(clone);\n    });\n  }\n\n  getCloneCount() {\n    if (this.isLoop()) {\n      const {\n        options\n      } = this;\n\n      if (options.clones) {\n        return options.clones;\n      }\n\n      const perPage = max(...this.breakpoints.map(_ref5 => {\n        let [, options2] = _ref5;\n        return options2.perPage;\n      }));\n      return perPage * ((options.flickMaxPages || 1) + 1);\n    }\n\n    return 0;\n  }\n\n  renderArrows() {\n    let html = \"\";\n    html += `<div class=\"${this.options.classes.arrows}\">`;\n    html += this.renderArrow(true);\n    html += this.renderArrow(false);\n    html += `</div>`;\n    return html;\n  }\n\n  renderArrow(prev) {\n    const {\n      classes,\n      i18n\n    } = this.options;\n    const attrs = {\n      class: `${classes.arrow} ${prev ? classes.prev : classes.next}`,\n      type: \"button\",\n      ariaLabel: prev ? i18n.prev : i18n.next\n    };\n    return `<button ${this.buildAttrs(attrs)}><svg xmlns=\"${XML_NAME_SPACE}\" viewBox=\"0 0 ${SIZE} ${SIZE}\" width=\"${SIZE}\" height=\"${SIZE}\"><path d=\"${this.options.arrowPath || PATH}\" /></svg></button>`;\n  }\n\n  html() {\n    const {\n      rootClass,\n      listTag,\n      arrows,\n      beforeTrack,\n      afterTrack,\n      slider,\n      beforeSlider,\n      afterSlider\n    } = this.config;\n    let html = \"\";\n    html += `<div id=\"${this.id}\" class=\"${this.buildClasses()} ${rootClass || \"\"}\">`;\n    html += `<style>${this.Style.build()}</style>`;\n\n    if (slider) {\n      html += beforeSlider || \"\";\n      html += `<div class=\"splide__slider\">`;\n    }\n\n    html += beforeTrack || \"\";\n\n    if (arrows) {\n      html += this.renderArrows();\n    }\n\n    html += `<div class=\"splide__track\">`;\n    html += `<${listTag} class=\"splide__list\">`;\n    html += this.renderSlides();\n    html += `</${listTag}>`;\n    html += `</div>`;\n    html += afterTrack || \"\";\n\n    if (slider) {\n      html += `</div>`;\n      html += afterSlider || \"\";\n    }\n\n    html += `</div>`;\n    return html;\n  }\n\n}\n\nexport { CLASSES, CLASS_ACTIVE, CLASS_ARROW, CLASS_ARROWS, CLASS_ARROW_NEXT, CLASS_ARROW_PREV, CLASS_AUTOPLAY, CLASS_CLONE, CLASS_CONTAINER, CLASS_INITIALIZED, CLASS_LIST, CLASS_LOADING, CLASS_NEXT, CLASS_PAGINATION, CLASS_PAGINATION_PAGE, CLASS_PAUSE, CLASS_PLAY, CLASS_PREV, CLASS_PROGRESS, CLASS_PROGRESS_BAR, CLASS_ROOT, CLASS_SLIDE, CLASS_SLIDER, CLASS_SPINNER, CLASS_TRACK, CLASS_VISIBLE, EVENT_ACTIVE, EVENT_ARROWS_MOUNTED, EVENT_ARROWS_UPDATED, EVENT_AUTOPLAY_PAUSE, EVENT_AUTOPLAY_PLAY, EVENT_AUTOPLAY_PLAYING, EVENT_CLICK, EVENT_DESTROY, EVENT_DRAG, EVENT_DRAGGED, EVENT_DRAGGING, EVENT_HIDDEN, EVENT_INACTIVE, EVENT_LAZYLOAD_LOADED, EVENT_MOUNTED, EVENT_MOVE, EVENT_MOVED, EVENT_NAVIGATION_MOUNTED, EVENT_PAGINATION_MOUNTED, EVENT_PAGINATION_UPDATED, EVENT_READY, EVENT_REFRESH, EVENT_REPOSITIONED, EVENT_RESIZE, EVENT_RESIZED, EVENT_SCROLL, EVENT_SCROLLED, EVENT_SHIFTED, EVENT_SLIDE_KEYDOWN, EVENT_UPDATED, EVENT_VISIBLE, EventBus, EventInterface, RequestInterval, STATUS_CLASSES, Splide, SplideRenderer, State, Throttle, Splide as default };","map":{"version":3,"sources":["C:/Users/Thefallen123/Desktop/Github Desktop/Projects/Project-2/node_modules/@splidejs/splide/dist/js/splide.esm.js"],"names":["PROJECT_CODE","DATA_ATTRIBUTE","CREATED","MOUNTED","IDLE","MOVING","DESTROYED","STATES","DEFAULT_EVENT_PRIORITY","DEFAULT_USER_EVENT_PRIORITY","empty","array","length","isObject","subject","isNull","isArray","Array","isFunction","isString","isUndefined","isHTMLElement","HTMLElement","toArray","value","forEach","values","iteratee","includes","indexOf","push","items","arrayProto","prototype","slice","arrayLike","start","end","call","find","predicate","filter","toggleClass","elm","classes","add","name","classList","addClass","split","append","parent","children","appendChild","bind","before","nodes","ref","node","parentNode","insertBefore","matches","selector","child","firstElementChild","forOwn","object","right","keys","Object","reverse","i","key","assign","arguments","source","merge","removeAttribute","attrs","attr","setAttribute","value2","String","create","tag","document","createElement","style","prop","getComputedStyle","style2","display","display2","focus","preventScroll","getAttribute","hasClass","className","contains","rect","target","getBoundingClientRect","remove","removeChild","measure","div","width","parseHtml","html","DOMParser","parseFromString","body","prevent","e","stopPropagation","preventDefault","stopImmediatePropagation","query","querySelector","queryAll","querySelectorAll","removeClass","unit","assert","condition","message","Error","nextTick","callback","setTimeout","noop","raf","func","requestAnimationFrame","min","max","floor","ceil","abs","Math","approximatelyEqual","x","y","epsilon","between","number","minOrMax","maxOrMin","exclusive","minimum","maximum","clamp","sign","camelToKebab","string","replace","toLowerCase","format","replacements","replacement","pad","ids","uniqueId","prefix","EventBus","handlers","on","events","priority","forEachEvent","event","namespace","_event","_callback","_namespace","_priority","_key","sort","handler1","handler2","off","eventHandlers","handler","offBy","emit","apply","destroy","join","eventNS","fragments","EVENT_MOUNTED","EVENT_READY","EVENT_MOVE","EVENT_MOVED","EVENT_SHIFTED","EVENT_CLICK","EVENT_ACTIVE","EVENT_INACTIVE","EVENT_VISIBLE","EVENT_HIDDEN","EVENT_SLIDE_KEYDOWN","EVENT_REFRESH","EVENT_UPDATED","EVENT_RESIZE","EVENT_RESIZED","EVENT_REPOSITIONED","EVENT_DRAG","EVENT_DRAGGING","EVENT_DRAGGED","EVENT_SCROLL","EVENT_SCROLLED","EVENT_DESTROY","EVENT_ARROWS_MOUNTED","EVENT_ARROWS_UPDATED","EVENT_PAGINATION_MOUNTED","EVENT_PAGINATION_UPDATED","EVENT_NAVIGATION_MOUNTED","EVENT_AUTOPLAY_PLAY","EVENT_AUTOPLAY_PLAYING","EVENT_AUTOPLAY_PAUSE","EVENT_LAZYLOAD_LOADED","EventInterface","Splide2","listeners","targets","options","event2","addEventListener","unbind","listener","removeEventListener","data","RequestInterval","interval","onInterval","onUpdate","limit","now","Date","startTime","rate","id","paused","count","update","elapsed","pause","resume","cancel","rewind","cancelAnimationFrame","set","time","isPaused","State","initialState","state","is","states","Throttle","duration","throttled","Options","Components2","throttledObserve","observe","initialOptions","points","currPoint","setup","JSON","parse","root","breakpoints","isMin","mediaQuery","n","m","map","point","matchMedia","mount","completely","item","item2","onMatch","newOptions","RTL","TTB","ORIENTATION_MAP","marginRight","autoWidth","fixedWidth","paddingLeft","paddingRight","left","X","Y","ArrowLeft","ArrowRight","Direction","resolve","axisOnly","direction","index","orient","CLASS_ROOT","CLASS_SLIDER","CLASS_TRACK","CLASS_LIST","CLASS_SLIDE","CLASS_CLONE","CLASS_CONTAINER","CLASS_ARROWS","CLASS_ARROW","CLASS_ARROW_PREV","CLASS_ARROW_NEXT","CLASS_PAGINATION","CLASS_PAGINATION_PAGE","CLASS_PROGRESS","CLASS_PROGRESS_BAR","CLASS_AUTOPLAY","CLASS_PLAY","CLASS_PAUSE","CLASS_SPINNER","CLASS_INITIALIZED","CLASS_ACTIVE","CLASS_PREV","CLASS_NEXT","CLASS_VISIBLE","CLASS_LOADING","STATUS_CLASSES","CLASSES","slide","clone","arrows","arrow","prev","next","pagination","page","spinner","Elements","elements","slides","slider","track","list","collect","identify","getClasses","refresh","autoplay","bar","play","type","drag","isNavigation","ROLE","ARIA_CONTROLS","ARIA_CURRENT","ARIA_LABEL","ARIA_HIDDEN","TAB_INDEX","DISABLED","ARIA_ORIENTATION","ALL_ATTRIBUTES","SLIDE","LOOP","FADE","Slide$1","slideIndex","destroyEvents","Components","updateOnMove","styles","isClone","container","focusableNodes","destroyed","self","initNavigation","onMove","idx","label","i18n","slideX","controls","splides","splide","updateActivity","isActive","currIndex","updateVisibility","isVisible","active","visible","hidden","slideFocus","style$1","useContainer","curr","cloneStatus","trackRect","slideRect","isWithin","from","distance","diff","Slides","Slides2","init","Slide1","Slide2","register","forEach$1","get","excludeClones","getIn","Controller","toIndex","hasFocus","perPage","getAt","observeImages","remove$1","matcher","images","img","getLength","isEnough","Layout","vertical","rootRect","window","resize","cssPadding","newRect","height","cssTrackHeight","gap","cssSlideWidth","setSlidesHeight","cssSlideHeight","padding","cssHeight","heightRatio","cssSlideSize","fixedHeight","autoHeight","listSize","slideSize","withoutGap","Slide","getGap","totalSize","sliderSize","parseFloat","getPadding","Clones","clones","cloneCount","computeCloneCount","generate","isHead","cloneDeep","cloneNode","clones2","fixedSize","fixedCount","baseCount","flickMaxPages","Move","Transition","reposition","isBusy","Scroll","jump","move","dest","position","getPosition","translate","shift","trimSpace","go","toPosition","preventLoop","destination","loop","transform","exceededMin","exceededLimit","exceededMax","backwards","excess","getLimit","size","minDistance","Infinity","trimming","offset","trim","getEnd","waitForTransition","isLoop","isSlide","prevIndex","slideCount","perMove","control","allowSameIndex","useScroll","scroll","speed","setIndex","useIndex","snap","toDest","indicator","match","computeDestIndex","getNext","getPrev","getAdjacent","incremental","toPage","closest","getIndex","XML_NAME_SPACE","PATH","SIZE","Arrows","wrapper","created","createArrows","listen","createArrow","prev2","arrowPath","nextIndex","prevLabel","last","nextLabel","first","disabled","INTERVAL_DATA_ATTRIBUTE","Autoplay","hovered","focused","initButton","forPause","button","pauseOnHover","autoToggle","pauseOnFocus","updateInterval","resetProgress","manual","Cover","cover","toggle","src","BOUNCE_DIFF_THRESHOLD","BOUNCE_DURATION","FRICTION_FACTOR","BASE_VELOCITY","MIN_DURATION","scrollCallback","clear","suppressConstraint","friction","computeDuration","onScrolled","easing","bounce","t","easingFunc","pow","SCROLL_LISTENER_OPTIONS","passive","capture","FRICTION","LOG_INTERVAL","POINTER_DOWN_EVENTS","POINTER_MOVE_EVENTS","POINTER_UP_EVENTS","Drag","basePosition","baseEvent","prevBaseEvent","lastEvent","isFree","dragging","hasExceeded","clickPrevented","onPointerDown","onClick","disable","noDrag","isTouch","isTouchEvent","isDraggable","onPointerMove","onPointerUp","save","cancelable","coordOf","constrain","expired","timeOf","exceeded","dragMinThreshold","thresholds","mouse","touch","isSliderDirection","velocity","computeVelocity","computeDestination","diffX","diffY","base","diffCoord","diffTime","isFlick","flickPower","orthogonal","touches","timeStamp","TouchEvent","isDragging","IE_ARROW_KEYS","KEYBOARD_EVENT","Keyboard","onUpdated","keyboard","onKeydown","_disabled","normalizedKey","SRC_DATA_ATTRIBUTE","SRCSET_DATA_ATTRIBUTE","IMAGE_SELECTOR","LazyLoad","isSequential","lazyLoad","_Slide","_img","srcset","parentElement","_spinner","loadNext","preloadPages","load","onLoad","error","Pagination","createPagination","li","class","text","pageX","TRIGGER_KEYS","Sync","isParent","sync","navigate","remount","instance","Wheel","wheel","onWheel","deltaY","shouldPrevent","releaseWheel","ComponentConstructors","freeze","__proto__","I18N","DEFAULTS","Fade","done","endCallback","getSpeed","rewindSpeed","transition","_Splide","constructor","_options","_Extensions","defaults","Extensions","_Components","_Transition","Constructors","Component","component","Splide","CLASS_RENDERED","RENDERER_DEFAULT_CONFIG","listTag","slideTag","Style","rule","breakpoint","selectors","build","css","default","buildSelectors","SplideRenderer","contents","config","clean","parseBreakpoints","initSlides","registerRootStyles","registerTrackStyles","registerSlideStyles","registerListStyles","content","buildStyles","generateClones","Style2","buildTranslate","cssAspectRatio","cssOffsetClones","cssOffsetGaps","isCenter","buildCssValue","cssOffsetCenter","Boolean","getCloneCount","isFixedWidth","unit2","parseCssValue","percent","gapOffset","gaps","isVertical","buildClasses","buildAttrs","renderSlides","background","unshift","options2","renderArrows","renderArrow","ariaLabel","rootClass","beforeTrack","afterTrack","beforeSlider","afterSlider"],"mappings":"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","sourcesContent":["/*!\n * Splide.js\n * Version  : 3.6.9\n * License  : MIT\n * Copyright: 2021 Naotoshi Fujita\n */\nconst PROJECT_CODE = \"splide\";\nconst DATA_ATTRIBUTE = `data-${PROJECT_CODE}`;\n\nconst CREATED = 1;\nconst MOUNTED = 2;\nconst IDLE = 3;\nconst MOVING = 4;\nconst DESTROYED = 5;\nconst STATES = {\n  CREATED,\n  MOUNTED,\n  IDLE,\n  MOVING,\n  DESTROYED\n};\n\nconst DEFAULT_EVENT_PRIORITY = 10;\nconst DEFAULT_USER_EVENT_PRIORITY = 20;\n\nfunction empty(array) {\n  array.length = 0;\n}\n\nfunction isObject(subject) {\n  return !isNull(subject) && typeof subject === \"object\";\n}\nfunction isArray(subject) {\n  return Array.isArray(subject);\n}\nfunction isFunction(subject) {\n  return typeof subject === \"function\";\n}\nfunction isString(subject) {\n  return typeof subject === \"string\";\n}\nfunction isUndefined(subject) {\n  return typeof subject === \"undefined\";\n}\nfunction isNull(subject) {\n  return subject === null;\n}\nfunction isHTMLElement(subject) {\n  return subject instanceof HTMLElement;\n}\n\nfunction toArray(value) {\n  return isArray(value) ? value : [value];\n}\n\nfunction forEach(values, iteratee) {\n  toArray(values).forEach(iteratee);\n}\n\nfunction includes(array, value) {\n  return array.indexOf(value) > -1;\n}\n\nfunction push(array, items) {\n  array.push(...toArray(items));\n  return array;\n}\n\nconst arrayProto = Array.prototype;\n\nfunction slice(arrayLike, start, end) {\n  return arrayProto.slice.call(arrayLike, start, end);\n}\n\nfunction find(arrayLike, predicate) {\n  return slice(arrayLike).filter(predicate)[0];\n}\n\nfunction toggleClass(elm, classes, add) {\n  if (elm) {\n    forEach(classes, (name) => {\n      if (name) {\n        elm.classList[add ? \"add\" : \"remove\"](name);\n      }\n    });\n  }\n}\n\nfunction addClass(elm, classes) {\n  toggleClass(elm, isString(classes) ? classes.split(\" \") : classes, true);\n}\n\nfunction append(parent, children) {\n  forEach(children, parent.appendChild.bind(parent));\n}\n\nfunction before(nodes, ref) {\n  forEach(nodes, (node) => {\n    const parent = ref.parentNode;\n    if (parent) {\n      parent.insertBefore(node, ref);\n    }\n  });\n}\n\nfunction matches(elm, selector) {\n  return isHTMLElement(elm) && (elm[\"msMatchesSelector\"] || elm.matches).call(elm, selector);\n}\n\nfunction children(parent, selector) {\n  return parent ? slice(parent.children).filter((child) => matches(child, selector)) : [];\n}\n\nfunction child(parent, selector) {\n  return selector ? children(parent, selector)[0] : parent.firstElementChild;\n}\n\nfunction forOwn(object, iteratee, right) {\n  if (object) {\n    let keys = Object.keys(object);\n    keys = right ? keys.reverse() : keys;\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key !== \"__proto__\") {\n        if (iteratee(object[key], key) === false) {\n          break;\n        }\n      }\n    }\n  }\n  return object;\n}\n\nfunction assign(object) {\n  slice(arguments, 1).forEach((source) => {\n    forOwn(source, (value, key) => {\n      object[key] = source[key];\n    });\n  });\n  return object;\n}\n\nfunction merge(object, source) {\n  forOwn(source, (value, key) => {\n    if (isArray(value)) {\n      object[key] = value.slice();\n    } else if (isObject(value)) {\n      object[key] = merge(isObject(object[key]) ? object[key] : {}, value);\n    } else {\n      object[key] = value;\n    }\n  });\n  return object;\n}\n\nfunction removeAttribute(elm, attrs) {\n  if (elm) {\n    forEach(attrs, (attr) => {\n      elm.removeAttribute(attr);\n    });\n  }\n}\n\nfunction setAttribute(elm, attrs, value) {\n  if (isObject(attrs)) {\n    forOwn(attrs, (value2, name) => {\n      setAttribute(elm, name, value2);\n    });\n  } else {\n    isNull(value) ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));\n  }\n}\n\nfunction create(tag, attrs, parent) {\n  const elm = document.createElement(tag);\n  if (attrs) {\n    isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);\n  }\n  parent && append(parent, elm);\n  return elm;\n}\n\nfunction style(elm, prop, value) {\n  if (isUndefined(value)) {\n    return getComputedStyle(elm)[prop];\n  }\n  if (!isNull(value)) {\n    const { style: style2 } = elm;\n    value = `${value}`;\n    if (style2[prop] !== value) {\n      style2[prop] = value;\n    }\n  }\n}\n\nfunction display(elm, display2) {\n  style(elm, \"display\", display2);\n}\n\nfunction focus(elm) {\n  elm[\"setActive\"] && elm[\"setActive\"]() || elm.focus({ preventScroll: true });\n}\n\nfunction getAttribute(elm, attr) {\n  return elm.getAttribute(attr);\n}\n\nfunction hasClass(elm, className) {\n  return elm && elm.classList.contains(className);\n}\n\nfunction rect(target) {\n  return target.getBoundingClientRect();\n}\n\nfunction remove(nodes) {\n  forEach(nodes, (node) => {\n    if (node && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  });\n}\n\nfunction measure(parent, value) {\n  if (isString(value)) {\n    const div = create(\"div\", { style: `width: ${value}; position: absolute;` }, parent);\n    value = rect(div).width;\n    remove(div);\n  }\n  return value;\n}\n\nfunction parseHtml(html) {\n  return child(new DOMParser().parseFromString(html, \"text/html\").body);\n}\n\nfunction prevent(e, stopPropagation) {\n  e.preventDefault();\n  if (stopPropagation) {\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n  }\n}\n\nfunction query(parent, selector) {\n  return parent && parent.querySelector(selector);\n}\n\nfunction queryAll(parent, selector) {\n  return slice(parent.querySelectorAll(selector));\n}\n\nfunction removeClass(elm, classes) {\n  toggleClass(elm, classes, false);\n}\n\nfunction unit(value) {\n  return isString(value) ? value : value ? `${value}px` : \"\";\n}\n\nfunction assert(condition, message = \"\") {\n  if (!condition) {\n    throw new Error(`[${PROJECT_CODE}] ${message}`);\n  }\n}\n\nfunction nextTick(callback) {\n  setTimeout(callback);\n}\n\nconst noop = () => {\n};\n\nfunction raf(func) {\n  return requestAnimationFrame(func);\n}\n\nconst { min, max, floor, ceil, abs } = Math;\n\nfunction approximatelyEqual(x, y, epsilon) {\n  return abs(x - y) < epsilon;\n}\n\nfunction between(number, minOrMax, maxOrMin, exclusive) {\n  const minimum = min(minOrMax, maxOrMin);\n  const maximum = max(minOrMax, maxOrMin);\n  return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;\n}\n\nfunction clamp(number, x, y) {\n  const minimum = min(x, y);\n  const maximum = max(x, y);\n  return min(max(minimum, number), maximum);\n}\n\nfunction sign(x) {\n  return +(x > 0) - +(x < 0);\n}\n\nfunction camelToKebab(string) {\n  return string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\nfunction format(string, replacements) {\n  forEach(replacements, (replacement) => {\n    string = string.replace(\"%s\", `${replacement}`);\n  });\n  return string;\n}\n\nfunction pad(number) {\n  return number < 10 ? `0${number}` : `${number}`;\n}\n\nconst ids = {};\nfunction uniqueId(prefix) {\n  return `${prefix}${pad(ids[prefix] = (ids[prefix] || 0) + 1)}`;\n}\n\nfunction EventBus() {\n  let handlers = {};\n  function on(events, callback, key, priority = DEFAULT_EVENT_PRIORITY) {\n    forEachEvent(events, (event, namespace) => {\n      handlers[event] = handlers[event] || [];\n      push(handlers[event], {\n        _event: event,\n        _callback: callback,\n        _namespace: namespace,\n        _priority: priority,\n        _key: key\n      }).sort((handler1, handler2) => handler1._priority - handler2._priority);\n    });\n  }\n  function off(events, key) {\n    forEachEvent(events, (event, namespace) => {\n      const eventHandlers = handlers[event];\n      handlers[event] = eventHandlers && eventHandlers.filter((handler) => {\n        return handler._key ? handler._key !== key : key || handler._namespace !== namespace;\n      });\n    });\n  }\n  function offBy(key) {\n    forOwn(handlers, (eventHandlers, event) => {\n      off(event, key);\n    });\n  }\n  function emit(event) {\n    (handlers[event] || []).forEach((handler) => {\n      handler._callback.apply(handler, slice(arguments, 1));\n    });\n  }\n  function destroy() {\n    handlers = {};\n  }\n  function forEachEvent(events, iteratee) {\n    toArray(events).join(\" \").split(\" \").forEach((eventNS) => {\n      const fragments = eventNS.split(\".\");\n      iteratee(fragments[0], fragments[1]);\n    });\n  }\n  return {\n    on,\n    off,\n    offBy,\n    emit,\n    destroy\n  };\n}\n\nconst EVENT_MOUNTED = \"mounted\";\nconst EVENT_READY = \"ready\";\nconst EVENT_MOVE = \"move\";\nconst EVENT_MOVED = \"moved\";\nconst EVENT_SHIFTED = \"shifted\";\nconst EVENT_CLICK = \"click\";\nconst EVENT_ACTIVE = \"active\";\nconst EVENT_INACTIVE = \"inactive\";\nconst EVENT_VISIBLE = \"visible\";\nconst EVENT_HIDDEN = \"hidden\";\nconst EVENT_SLIDE_KEYDOWN = \"slide:keydown\";\nconst EVENT_REFRESH = \"refresh\";\nconst EVENT_UPDATED = \"updated\";\nconst EVENT_RESIZE = \"resize\";\nconst EVENT_RESIZED = \"resized\";\nconst EVENT_REPOSITIONED = \"repositioned\";\nconst EVENT_DRAG = \"drag\";\nconst EVENT_DRAGGING = \"dragging\";\nconst EVENT_DRAGGED = \"dragged\";\nconst EVENT_SCROLL = \"scroll\";\nconst EVENT_SCROLLED = \"scrolled\";\nconst EVENT_DESTROY = \"destroy\";\nconst EVENT_ARROWS_MOUNTED = \"arrows:mounted\";\nconst EVENT_ARROWS_UPDATED = \"arrows:updated\";\nconst EVENT_PAGINATION_MOUNTED = \"pagination:mounted\";\nconst EVENT_PAGINATION_UPDATED = \"pagination:updated\";\nconst EVENT_NAVIGATION_MOUNTED = \"navigation:mounted\";\nconst EVENT_AUTOPLAY_PLAY = \"autoplay:play\";\nconst EVENT_AUTOPLAY_PLAYING = \"autoplay:playing\";\nconst EVENT_AUTOPLAY_PAUSE = \"autoplay:pause\";\nconst EVENT_LAZYLOAD_LOADED = \"lazyload:loaded\";\n\nfunction EventInterface(Splide2) {\n  const { event } = Splide2;\n  const key = {};\n  let listeners = [];\n  function on(events, callback, priority) {\n    event.on(events, callback, key, priority);\n  }\n  function off(events) {\n    event.off(events, key);\n  }\n  function bind(targets, events, callback, options) {\n    forEachEvent(targets, events, (target, event2) => {\n      listeners.push([target, event2, callback, options]);\n      target.addEventListener(event2, callback, options);\n    });\n  }\n  function unbind(targets, events, callback) {\n    forEachEvent(targets, events, (target, event2) => {\n      listeners = listeners.filter((listener) => {\n        if (listener[0] === target && listener[1] === event2 && (!callback || listener[2] === callback)) {\n          target.removeEventListener(event2, listener[2], listener[3]);\n          return false;\n        }\n        return true;\n      });\n    });\n  }\n  function forEachEvent(targets, events, iteratee) {\n    forEach(targets, (target) => {\n      if (target) {\n        events.split(\" \").forEach(iteratee.bind(null, target));\n      }\n    });\n  }\n  function destroy() {\n    listeners = listeners.filter((data) => unbind(data[0], data[1]));\n    event.offBy(key);\n  }\n  event.on(EVENT_DESTROY, destroy, key);\n  return {\n    on,\n    off,\n    emit: event.emit,\n    bind,\n    unbind,\n    destroy\n  };\n}\n\nfunction RequestInterval(interval, onInterval, onUpdate, limit) {\n  const { now } = Date;\n  let startTime;\n  let rate = 0;\n  let id;\n  let paused = true;\n  let count = 0;\n  function update() {\n    if (!paused) {\n      const elapsed = now() - startTime;\n      if (elapsed >= interval) {\n        rate = 1;\n        startTime = now();\n      } else {\n        rate = elapsed / interval;\n      }\n      if (onUpdate) {\n        onUpdate(rate);\n      }\n      if (rate === 1) {\n        onInterval();\n        if (limit && ++count >= limit) {\n          return pause();\n        }\n      }\n      raf(update);\n    }\n  }\n  function start(resume) {\n    !resume && cancel();\n    startTime = now() - (resume ? rate * interval : 0);\n    paused = false;\n    raf(update);\n  }\n  function pause() {\n    paused = true;\n  }\n  function rewind() {\n    startTime = now();\n    rate = 0;\n    if (onUpdate) {\n      onUpdate(rate);\n    }\n  }\n  function cancel() {\n    cancelAnimationFrame(id);\n    rate = 0;\n    id = 0;\n    paused = true;\n  }\n  function set(time) {\n    interval = time;\n  }\n  function isPaused() {\n    return paused;\n  }\n  return {\n    start,\n    rewind,\n    pause,\n    cancel,\n    set,\n    isPaused\n  };\n}\n\nfunction State(initialState) {\n  let state = initialState;\n  function set(value) {\n    state = value;\n  }\n  function is(states) {\n    return includes(toArray(states), state);\n  }\n  return { set, is };\n}\n\nfunction Throttle(func, duration) {\n  let interval;\n  function throttled() {\n    if (!interval) {\n      interval = RequestInterval(duration || 0, () => {\n        func.apply(this, arguments);\n        interval = null;\n      }, null, 1);\n      interval.start();\n    }\n  }\n  return throttled;\n}\n\nfunction Options(Splide2, Components2, options) {\n  const throttledObserve = Throttle(observe);\n  let initialOptions;\n  let points;\n  let currPoint;\n  function setup() {\n    try {\n      merge(options, JSON.parse(getAttribute(Splide2.root, DATA_ATTRIBUTE)));\n    } catch (e) {\n      assert(false, e.message);\n    }\n    initialOptions = merge({}, options);\n    const { breakpoints } = options;\n    if (breakpoints) {\n      const isMin = options.mediaQuery === \"min\";\n      points = Object.keys(breakpoints).sort((n, m) => isMin ? +m - +n : +n - +m).map((point) => [\n        point,\n        matchMedia(`(${isMin ? \"min\" : \"max\"}-width:${point}px)`)\n      ]);\n      observe();\n    }\n  }\n  function mount() {\n    if (points) {\n      addEventListener(\"resize\", throttledObserve);\n    }\n  }\n  function destroy(completely) {\n    if (completely) {\n      removeEventListener(\"resize\", throttledObserve);\n    }\n  }\n  function observe() {\n    const item = find(points, (item2) => item2[1].matches) || [];\n    if (item[0] !== currPoint) {\n      onMatch(currPoint = item[0]);\n    }\n  }\n  function onMatch(point) {\n    const newOptions = options.breakpoints[point] || initialOptions;\n    if (newOptions.destroy) {\n      Splide2.options = initialOptions;\n      Splide2.destroy(newOptions.destroy === \"completely\");\n    } else {\n      if (Splide2.state.is(DESTROYED)) {\n        destroy(true);\n        Splide2.mount();\n      }\n      Splide2.options = newOptions;\n    }\n  }\n  return {\n    setup,\n    mount,\n    destroy\n  };\n}\n\nconst RTL = \"rtl\";\nconst TTB = \"ttb\";\n\nconst ORIENTATION_MAP = {\n  marginRight: [\"marginBottom\", \"marginLeft\"],\n  autoWidth: [\"autoHeight\"],\n  fixedWidth: [\"fixedHeight\"],\n  paddingLeft: [\"paddingTop\", \"paddingRight\"],\n  paddingRight: [\"paddingBottom\", \"paddingLeft\"],\n  width: [\"height\"],\n  left: [\"top\", \"right\"],\n  right: [\"bottom\", \"left\"],\n  x: [\"y\"],\n  X: [\"Y\"],\n  Y: [\"X\"],\n  ArrowLeft: [\"ArrowUp\", \"ArrowRight\"],\n  ArrowRight: [\"ArrowDown\", \"ArrowLeft\"]\n};\nfunction Direction(Splide2, Components2, options) {\n  function resolve(prop, axisOnly) {\n    const { direction } = options;\n    const index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;\n    return ORIENTATION_MAP[prop][index] || prop;\n  }\n  function orient(value) {\n    return value * (options.direction === RTL ? 1 : -1);\n  }\n  return {\n    resolve,\n    orient\n  };\n}\n\nconst CLASS_ROOT = PROJECT_CODE;\nconst CLASS_SLIDER = `${PROJECT_CODE}__slider`;\nconst CLASS_TRACK = `${PROJECT_CODE}__track`;\nconst CLASS_LIST = `${PROJECT_CODE}__list`;\nconst CLASS_SLIDE = `${PROJECT_CODE}__slide`;\nconst CLASS_CLONE = `${CLASS_SLIDE}--clone`;\nconst CLASS_CONTAINER = `${CLASS_SLIDE}__container`;\nconst CLASS_ARROWS = `${PROJECT_CODE}__arrows`;\nconst CLASS_ARROW = `${PROJECT_CODE}__arrow`;\nconst CLASS_ARROW_PREV = `${CLASS_ARROW}--prev`;\nconst CLASS_ARROW_NEXT = `${CLASS_ARROW}--next`;\nconst CLASS_PAGINATION = `${PROJECT_CODE}__pagination`;\nconst CLASS_PAGINATION_PAGE = `${CLASS_PAGINATION}__page`;\nconst CLASS_PROGRESS = `${PROJECT_CODE}__progress`;\nconst CLASS_PROGRESS_BAR = `${CLASS_PROGRESS}__bar`;\nconst CLASS_AUTOPLAY = `${PROJECT_CODE}__autoplay`;\nconst CLASS_PLAY = `${PROJECT_CODE}__play`;\nconst CLASS_PAUSE = `${PROJECT_CODE}__pause`;\nconst CLASS_SPINNER = `${PROJECT_CODE}__spinner`;\nconst CLASS_INITIALIZED = \"is-initialized\";\nconst CLASS_ACTIVE = \"is-active\";\nconst CLASS_PREV = \"is-prev\";\nconst CLASS_NEXT = \"is-next\";\nconst CLASS_VISIBLE = \"is-visible\";\nconst CLASS_LOADING = \"is-loading\";\nconst STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING];\nconst CLASSES = {\n  slide: CLASS_SLIDE,\n  clone: CLASS_CLONE,\n  arrows: CLASS_ARROWS,\n  arrow: CLASS_ARROW,\n  prev: CLASS_ARROW_PREV,\n  next: CLASS_ARROW_NEXT,\n  pagination: CLASS_PAGINATION,\n  page: CLASS_PAGINATION_PAGE,\n  spinner: CLASS_SPINNER\n};\n\nfunction Elements(Splide2, Components2, options) {\n  const { on } = EventInterface(Splide2);\n  const { root } = Splide2;\n  const elements = {};\n  const slides = [];\n  let classes;\n  let slider;\n  let track;\n  let list;\n  function setup() {\n    collect();\n    identify();\n    addClass(root, classes = getClasses());\n  }\n  function mount() {\n    on(EVENT_REFRESH, refresh, DEFAULT_EVENT_PRIORITY - 2);\n    on(EVENT_UPDATED, update);\n  }\n  function destroy() {\n    [root, track, list].forEach((elm) => {\n      removeAttribute(elm, \"style\");\n    });\n    empty(slides);\n    removeClass(root, classes);\n  }\n  function refresh() {\n    destroy();\n    setup();\n  }\n  function update() {\n    removeClass(root, classes);\n    addClass(root, classes = getClasses());\n  }\n  function collect() {\n    slider = child(root, `.${CLASS_SLIDER}`);\n    track = query(root, `.${CLASS_TRACK}`);\n    list = child(track, `.${CLASS_LIST}`);\n    assert(track && list, \"A track/list element is missing.\");\n    push(slides, children(list, `.${CLASS_SLIDE}:not(.${CLASS_CLONE})`));\n    const autoplay = find(`.${CLASS_AUTOPLAY}`);\n    const arrows = find(`.${CLASS_ARROWS}`);\n    assign(elements, {\n      root,\n      slider,\n      track,\n      list,\n      slides,\n      arrows,\n      autoplay,\n      prev: query(arrows, `.${CLASS_ARROW_PREV}`),\n      next: query(arrows, `.${CLASS_ARROW_NEXT}`),\n      bar: query(find(`.${CLASS_PROGRESS}`), `.${CLASS_PROGRESS_BAR}`),\n      play: query(autoplay, `.${CLASS_PLAY}`),\n      pause: query(autoplay, `.${CLASS_PAUSE}`)\n    });\n  }\n  function identify() {\n    const id = root.id || uniqueId(PROJECT_CODE);\n    root.id = id;\n    track.id = track.id || `${id}-track`;\n    list.id = list.id || `${id}-list`;\n  }\n  function find(selector) {\n    return child(root, selector) || child(slider, selector);\n  }\n  function getClasses() {\n    return [\n      `${CLASS_ROOT}--${options.type}`,\n      `${CLASS_ROOT}--${options.direction}`,\n      options.drag && `${CLASS_ROOT}--draggable`,\n      options.isNavigation && `${CLASS_ROOT}--nav`,\n      CLASS_ACTIVE\n    ];\n  }\n  return assign(elements, {\n    setup,\n    mount,\n    destroy\n  });\n}\n\nconst ROLE = \"role\";\nconst ARIA_CONTROLS = \"aria-controls\";\nconst ARIA_CURRENT = \"aria-current\";\nconst ARIA_LABEL = \"aria-label\";\nconst ARIA_HIDDEN = \"aria-hidden\";\nconst TAB_INDEX = \"tabindex\";\nconst DISABLED = \"disabled\";\nconst ARIA_ORIENTATION = \"aria-orientation\";\nconst ALL_ATTRIBUTES = [\n  ROLE,\n  ARIA_CONTROLS,\n  ARIA_CURRENT,\n  ARIA_LABEL,\n  ARIA_HIDDEN,\n  ARIA_ORIENTATION,\n  TAB_INDEX,\n  DISABLED\n];\n\nconst SLIDE = \"slide\";\nconst LOOP = \"loop\";\nconst FADE = \"fade\";\n\nfunction Slide$1(Splide2, index, slideIndex, slide) {\n  const { on, emit, bind, destroy: destroyEvents } = EventInterface(Splide2);\n  const { Components, root, options } = Splide2;\n  const { isNavigation, updateOnMove } = options;\n  const { resolve } = Components.Direction;\n  const styles = getAttribute(slide, \"style\");\n  const isClone = slideIndex > -1;\n  const container = child(slide, `.${CLASS_CONTAINER}`);\n  const focusableNodes = options.focusableNodes && queryAll(slide, options.focusableNodes);\n  let destroyed;\n  function mount() {\n    if (!isClone) {\n      slide.id = `${root.id}-slide${pad(index + 1)}`;\n    }\n    bind(slide, \"click keydown\", (e) => {\n      emit(e.type === \"click\" ? EVENT_CLICK : EVENT_SLIDE_KEYDOWN, self, e);\n    });\n    on([EVENT_REFRESH, EVENT_REPOSITIONED, EVENT_SHIFTED, EVENT_MOVED, EVENT_SCROLLED], update);\n    on(EVENT_NAVIGATION_MOUNTED, initNavigation);\n    if (updateOnMove) {\n      on(EVENT_MOVE, onMove);\n    }\n  }\n  function destroy() {\n    destroyed = true;\n    destroyEvents();\n    removeClass(slide, STATUS_CLASSES);\n    removeAttribute(slide, ALL_ATTRIBUTES);\n    setAttribute(slide, \"style\", styles);\n  }\n  function initNavigation() {\n    const idx = isClone ? slideIndex : index;\n    const label = format(options.i18n.slideX, idx + 1);\n    const controls = Splide2.splides.map((target) => target.splide.root.id).join(\" \");\n    setAttribute(slide, ARIA_LABEL, label);\n    setAttribute(slide, ARIA_CONTROLS, controls);\n    setAttribute(slide, ROLE, \"menuitem\");\n    updateActivity(isActive());\n  }\n  function onMove() {\n    if (!destroyed) {\n      update();\n    }\n  }\n  function update() {\n    if (!destroyed) {\n      const { index: currIndex } = Splide2;\n      updateActivity(isActive());\n      updateVisibility(isVisible());\n      toggleClass(slide, CLASS_PREV, index === currIndex - 1);\n      toggleClass(slide, CLASS_NEXT, index === currIndex + 1);\n    }\n  }\n  function updateActivity(active) {\n    if (active !== hasClass(slide, CLASS_ACTIVE)) {\n      toggleClass(slide, CLASS_ACTIVE, active);\n      if (isNavigation) {\n        setAttribute(slide, ARIA_CURRENT, active || null);\n      }\n      emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);\n    }\n  }\n  function updateVisibility(visible) {\n    const hidden = !visible && (!isActive() || isClone);\n    setAttribute(slide, ARIA_HIDDEN, hidden || null);\n    setAttribute(slide, TAB_INDEX, !hidden && options.slideFocus ? 0 : null);\n    if (focusableNodes) {\n      focusableNodes.forEach((node) => {\n        setAttribute(node, TAB_INDEX, hidden ? -1 : null);\n      });\n    }\n    if (visible !== hasClass(slide, CLASS_VISIBLE)) {\n      toggleClass(slide, CLASS_VISIBLE, visible);\n      emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);\n    }\n  }\n  function style$1(prop, value, useContainer) {\n    style(useContainer && container || slide, prop, value);\n  }\n  function isActive() {\n    const { index: curr } = Splide2;\n    return curr === index || options.cloneStatus && curr === slideIndex;\n  }\n  function isVisible() {\n    if (Splide2.is(FADE)) {\n      return isActive();\n    }\n    const trackRect = rect(Components.Elements.track);\n    const slideRect = rect(slide);\n    const left = resolve(\"left\");\n    const right = resolve(\"right\");\n    return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);\n  }\n  function isWithin(from, distance) {\n    let diff = abs(from - index);\n    if (!isClone && (options.rewind || Splide2.is(LOOP))) {\n      diff = min(diff, Splide2.length - diff);\n    }\n    return diff <= distance;\n  }\n  const self = {\n    index,\n    slideIndex,\n    slide,\n    container,\n    isClone,\n    mount,\n    destroy,\n    update,\n    style: style$1,\n    isWithin\n  };\n  return self;\n}\n\nfunction Slides(Splide2, Components2, options) {\n  const { on, emit, bind } = EventInterface(Splide2);\n  const { slides, list } = Components2.Elements;\n  const Slides2 = [];\n  function mount() {\n    init();\n    on(EVENT_REFRESH, refresh);\n    on([EVENT_MOUNTED, EVENT_REFRESH], () => {\n      Slides2.sort((Slide1, Slide2) => Slide1.index - Slide2.index);\n    });\n  }\n  function init() {\n    slides.forEach((slide, index) => {\n      register(slide, index, -1);\n    });\n  }\n  function destroy() {\n    forEach$1((Slide2) => {\n      Slide2.destroy();\n    });\n    empty(Slides2);\n  }\n  function refresh() {\n    destroy();\n    init();\n  }\n  function update() {\n    forEach$1((Slide2) => {\n      Slide2.update();\n    });\n  }\n  function register(slide, index, slideIndex) {\n    const object = Slide$1(Splide2, index, slideIndex, slide);\n    object.mount();\n    Slides2.push(object);\n  }\n  function get(excludeClones) {\n    return excludeClones ? filter((Slide2) => !Slide2.isClone) : Slides2;\n  }\n  function getIn(page) {\n    const { Controller } = Components2;\n    const index = Controller.toIndex(page);\n    const max = Controller.hasFocus() ? 1 : options.perPage;\n    return filter((Slide2) => between(Slide2.index, index, index + max - 1));\n  }\n  function getAt(index) {\n    return filter(index)[0];\n  }\n  function add(items, index) {\n    forEach(items, (slide) => {\n      if (isString(slide)) {\n        slide = parseHtml(slide);\n      }\n      if (isHTMLElement(slide)) {\n        const ref = slides[index];\n        ref ? before(slide, ref) : append(list, slide);\n        addClass(slide, options.classes.slide);\n        observeImages(slide, emit.bind(null, EVENT_RESIZE));\n      }\n    });\n    emit(EVENT_REFRESH);\n  }\n  function remove$1(matcher) {\n    remove(filter(matcher).map((Slide2) => Slide2.slide));\n    emit(EVENT_REFRESH);\n  }\n  function forEach$1(iteratee, excludeClones) {\n    get(excludeClones).forEach(iteratee);\n  }\n  function filter(matcher) {\n    return Slides2.filter(isFunction(matcher) ? matcher : (Slide2) => isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index));\n  }\n  function style(prop, value, useContainer) {\n    forEach$1((Slide2) => {\n      Slide2.style(prop, value, useContainer);\n    });\n  }\n  function observeImages(elm, callback) {\n    const images = queryAll(elm, \"img\");\n    let { length } = images;\n    if (length) {\n      images.forEach((img) => {\n        bind(img, \"load error\", () => {\n          if (!--length) {\n            callback();\n          }\n        });\n      });\n    } else {\n      callback();\n    }\n  }\n  function getLength(excludeClones) {\n    return excludeClones ? slides.length : Slides2.length;\n  }\n  function isEnough() {\n    return Slides2.length > options.perPage;\n  }\n  return {\n    mount,\n    destroy,\n    update,\n    register,\n    get,\n    getIn,\n    getAt,\n    add,\n    remove: remove$1,\n    forEach: forEach$1,\n    filter,\n    style,\n    getLength,\n    isEnough\n  };\n}\n\nfunction Layout(Splide2, Components2, options) {\n  const { on, bind, emit } = EventInterface(Splide2);\n  const { Slides } = Components2;\n  const { resolve } = Components2.Direction;\n  const { root, track, list } = Components2.Elements;\n  const { getAt } = Slides;\n  let vertical;\n  let rootRect;\n  function mount() {\n    init();\n    bind(window, \"resize load\", Throttle(emit.bind(this, EVENT_RESIZE)));\n    on([EVENT_UPDATED, EVENT_REFRESH], init);\n    on(EVENT_RESIZE, resize);\n  }\n  function init() {\n    rootRect = null;\n    vertical = options.direction === TTB;\n    style(root, \"maxWidth\", unit(options.width));\n    style(track, resolve(\"paddingLeft\"), cssPadding(false));\n    style(track, resolve(\"paddingRight\"), cssPadding(true));\n    resize();\n  }\n  function resize() {\n    const newRect = rect(root);\n    if (!rootRect || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {\n      style(track, \"height\", cssTrackHeight());\n      Slides.style(resolve(\"marginRight\"), unit(options.gap));\n      Slides.style(\"width\", cssSlideWidth() || null);\n      setSlidesHeight();\n      rootRect = newRect;\n      emit(EVENT_RESIZED);\n    }\n  }\n  function setSlidesHeight() {\n    Slides.style(\"height\", cssSlideHeight() || null, true);\n  }\n  function cssPadding(right) {\n    const { padding } = options;\n    const prop = resolve(right ? \"right\" : \"left\");\n    return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || \"0px\";\n  }\n  function cssTrackHeight() {\n    let height = \"\";\n    if (vertical) {\n      height = cssHeight();\n      assert(height, \"height or heightRatio is missing.\");\n      height = `calc(${height} - ${cssPadding(false)} - ${cssPadding(true)})`;\n    }\n    return height;\n  }\n  function cssHeight() {\n    return unit(options.height || rect(list).width * options.heightRatio);\n  }\n  function cssSlideWidth() {\n    return options.autoWidth ? \"\" : unit(options.fixedWidth) || (vertical ? \"\" : cssSlideSize());\n  }\n  function cssSlideHeight() {\n    return unit(options.fixedHeight) || (vertical ? options.autoHeight ? \"\" : cssSlideSize() : cssHeight());\n  }\n  function cssSlideSize() {\n    const gap = unit(options.gap);\n    return `calc((100%${gap && ` + ${gap}`})/${options.perPage || 1}${gap && ` - ${gap}`})`;\n  }\n  function listSize() {\n    return rect(list)[resolve(\"width\")];\n  }\n  function slideSize(index, withoutGap) {\n    const Slide = getAt(index || 0);\n    return Slide ? rect(Slide.slide)[resolve(\"width\")] + (withoutGap ? 0 : getGap()) : 0;\n  }\n  function totalSize(index, withoutGap) {\n    const Slide = getAt(index);\n    if (Slide) {\n      const right = rect(Slide.slide)[resolve(\"right\")];\n      const left = rect(list)[resolve(\"left\")];\n      return abs(right - left) + (withoutGap ? 0 : getGap());\n    }\n    return 0;\n  }\n  function sliderSize() {\n    return totalSize(Splide2.length - 1, true) - totalSize(-1, true);\n  }\n  function getGap() {\n    const Slide = getAt(0);\n    return Slide && parseFloat(style(Slide.slide, resolve(\"marginRight\"))) || 0;\n  }\n  function getPadding(right) {\n    return parseFloat(style(track, resolve(`padding${right ? \"Right\" : \"Left\"}`))) || 0;\n  }\n  return {\n    mount,\n    listSize,\n    slideSize,\n    sliderSize,\n    totalSize,\n    getPadding\n  };\n}\n\nfunction Clones(Splide2, Components2, options) {\n  const { on, emit } = EventInterface(Splide2);\n  const { Elements, Slides } = Components2;\n  const { resolve } = Components2.Direction;\n  const clones = [];\n  let cloneCount;\n  function mount() {\n    init();\n    on(EVENT_REFRESH, refresh);\n    on([EVENT_UPDATED, EVENT_RESIZE], observe);\n  }\n  function init() {\n    if (cloneCount = computeCloneCount()) {\n      generate(cloneCount);\n      emit(EVENT_RESIZE);\n    }\n  }\n  function destroy() {\n    remove(clones);\n    empty(clones);\n  }\n  function refresh() {\n    destroy();\n    init();\n  }\n  function observe() {\n    if (cloneCount < computeCloneCount()) {\n      emit(EVENT_REFRESH);\n    }\n  }\n  function generate(count) {\n    const slides = Slides.get().slice();\n    const { length } = slides;\n    if (length) {\n      while (slides.length < count) {\n        push(slides, slides);\n      }\n      push(slides.slice(-count), slides.slice(0, count)).forEach((Slide, index) => {\n        const isHead = index < count;\n        const clone = cloneDeep(Slide.slide, index);\n        isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);\n        push(clones, clone);\n        Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index);\n      });\n    }\n  }\n  function cloneDeep(elm, index) {\n    const clone = elm.cloneNode(true);\n    addClass(clone, options.classes.clone);\n    clone.id = `${Splide2.root.id}-clone${pad(index + 1)}`;\n    return clone;\n  }\n  function computeCloneCount() {\n    let { clones: clones2 } = options;\n    if (!Splide2.is(LOOP)) {\n      clones2 = 0;\n    } else if (!clones2) {\n      const fixedSize = measure(Elements.list, options[resolve(\"fixedWidth\")]);\n      const fixedCount = fixedSize && ceil(rect(Elements.track)[resolve(\"width\")] / fixedSize);\n      const baseCount = fixedCount || options[resolve(\"autoWidth\")] && Splide2.length || options.perPage;\n      clones2 = baseCount * (options.drag ? (options.flickMaxPages || 1) + 1 : 2);\n    }\n    return clones2;\n  }\n  return {\n    mount,\n    destroy\n  };\n}\n\nfunction Move(Splide2, Components2, options) {\n  const { on, emit } = EventInterface(Splide2);\n  const { slideSize, getPadding, totalSize, listSize, sliderSize } = Components2.Layout;\n  const { resolve, orient } = Components2.Direction;\n  const { list, track } = Components2.Elements;\n  let Transition;\n  function mount() {\n    Transition = Components2.Transition;\n    on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);\n  }\n  function destroy() {\n    removeAttribute(list, \"style\");\n  }\n  function reposition() {\n    if (!isBusy()) {\n      Components2.Scroll.cancel();\n      jump(Splide2.index);\n      emit(EVENT_REPOSITIONED);\n    }\n  }\n  function move(dest, index, prev, callback) {\n    if (!isBusy()) {\n      const { set } = Splide2.state;\n      const position = getPosition();\n      if (dest !== index) {\n        Transition.cancel();\n        translate(shift(position, dest > index), true);\n      }\n      set(MOVING);\n      emit(EVENT_MOVE, index, prev, dest);\n      Transition.start(index, () => {\n        set(IDLE);\n        emit(EVENT_MOVED, index, prev, dest);\n        if (options.trimSpace === \"move\" && dest !== prev && position === getPosition()) {\n          Components2.Controller.go(dest > prev ? \">\" : \"<\", false, callback);\n        } else {\n          callback && callback();\n        }\n      });\n    }\n  }\n  function jump(index) {\n    translate(toPosition(index, true));\n  }\n  function translate(position, preventLoop) {\n    if (!Splide2.is(FADE)) {\n      const destination = preventLoop ? position : loop(position);\n      list.style.transform = `translate${resolve(\"X\")}(${destination}px)`;\n      position !== destination && emit(EVENT_SHIFTED);\n    }\n  }\n  function loop(position) {\n    if (Splide2.is(LOOP)) {\n      const diff = orient(position - getPosition());\n      const exceededMin = exceededLimit(false, position) && diff < 0;\n      const exceededMax = exceededLimit(true, position) && diff > 0;\n      if (exceededMin || exceededMax) {\n        position = shift(position, exceededMax);\n      }\n    }\n    return position;\n  }\n  function shift(position, backwards) {\n    const excess = position - getLimit(backwards);\n    const size = sliderSize();\n    position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);\n    return position;\n  }\n  function cancel() {\n    translate(getPosition());\n    Transition.cancel();\n  }\n  function toIndex(position) {\n    const Slides = Components2.Slides.get();\n    let index = 0;\n    let minDistance = Infinity;\n    for (let i = 0; i < Slides.length; i++) {\n      const slideIndex = Slides[i].index;\n      const distance = abs(toPosition(slideIndex, true) - position);\n      if (distance <= minDistance) {\n        minDistance = distance;\n        index = slideIndex;\n      } else {\n        break;\n      }\n    }\n    return index;\n  }\n  function toPosition(index, trimming) {\n    const position = orient(totalSize(index - 1) - offset(index));\n    return trimming ? trim(position) : position;\n  }\n  function getPosition() {\n    const left = resolve(\"left\");\n    return rect(list)[left] - rect(track)[left] + orient(getPadding(false));\n  }\n  function trim(position) {\n    if (options.trimSpace && Splide2.is(SLIDE)) {\n      position = clamp(position, 0, orient(sliderSize() - listSize()));\n    }\n    return position;\n  }\n  function offset(index) {\n    const { focus } = options;\n    return focus === \"center\" ? (listSize() - slideSize(index, true)) / 2 : +focus * slideSize(index) || 0;\n  }\n  function getLimit(max) {\n    return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace);\n  }\n  function isBusy() {\n    return Splide2.state.is(MOVING) && options.waitForTransition;\n  }\n  function exceededLimit(max, position) {\n    position = isUndefined(position) ? getPosition() : position;\n    const exceededMin = max !== true && orient(position) < orient(getLimit(false));\n    const exceededMax = max !== false && orient(position) > orient(getLimit(true));\n    return exceededMin || exceededMax;\n  }\n  return {\n    mount,\n    destroy,\n    move,\n    jump,\n    translate,\n    shift,\n    cancel,\n    toIndex,\n    toPosition,\n    getPosition,\n    getLimit,\n    isBusy,\n    exceededLimit\n  };\n}\n\nfunction Controller(Splide2, Components2, options) {\n  const { on } = EventInterface(Splide2);\n  const { Move } = Components2;\n  const { getPosition, getLimit } = Move;\n  const { isEnough, getLength } = Components2.Slides;\n  const isLoop = Splide2.is(LOOP);\n  const isSlide = Splide2.is(SLIDE);\n  let currIndex = options.start || 0;\n  let prevIndex = currIndex;\n  let slideCount;\n  let perMove;\n  let perPage;\n  function mount() {\n    init();\n    on([EVENT_UPDATED, EVENT_REFRESH], init, DEFAULT_EVENT_PRIORITY - 1);\n  }\n  function init() {\n    slideCount = getLength(true);\n    perMove = options.perMove;\n    perPage = options.perPage;\n    currIndex = clamp(currIndex, 0, slideCount - 1);\n  }\n  function go(control, allowSameIndex, callback) {\n    const dest = parse(control);\n    if (options.useScroll) {\n      scroll(dest, true, true, options.speed, callback);\n    } else {\n      const index = loop(dest);\n      if (index > -1 && !Move.isBusy() && (allowSameIndex || index !== currIndex)) {\n        setIndex(index);\n        Move.move(dest, index, prevIndex, callback);\n      }\n    }\n  }\n  function scroll(destination, useIndex, snap, duration, callback) {\n    const dest = useIndex ? destination : toDest(destination);\n    Components2.Scroll.scroll(useIndex || snap ? Move.toPosition(dest, true) : destination, duration, () => {\n      setIndex(Move.toIndex(Move.getPosition()));\n      callback && callback();\n    });\n  }\n  function parse(control) {\n    let index = currIndex;\n    if (isString(control)) {\n      const [, indicator, number] = control.match(/([+\\-<>])(\\d+)?/) || [];\n      if (indicator === \"+\" || indicator === \"-\") {\n        index = computeDestIndex(currIndex + +`${indicator}${+number || 1}`, currIndex, true);\n      } else if (indicator === \">\") {\n        index = number ? toIndex(+number) : getNext(true);\n      } else if (indicator === \"<\") {\n        index = getPrev(true);\n      }\n    } else {\n      index = isLoop ? control : clamp(control, 0, getEnd());\n    }\n    return index;\n  }\n  function getNext(destination) {\n    return getAdjacent(false, destination);\n  }\n  function getPrev(destination) {\n    return getAdjacent(true, destination);\n  }\n  function getAdjacent(prev, destination) {\n    const number = perMove || (hasFocus() ? 1 : perPage);\n    const dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex);\n    if (dest === -1 && isSlide) {\n      if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {\n        return prev ? 0 : getEnd();\n      }\n    }\n    return destination ? dest : loop(dest);\n  }\n  function computeDestIndex(dest, from, incremental) {\n    if (isEnough()) {\n      const end = getEnd();\n      if (dest < 0 || dest > end) {\n        if (between(0, dest, from, true) || between(end, from, dest, true)) {\n          dest = toIndex(toPage(dest));\n        } else {\n          if (isLoop) {\n            dest = perMove || hasFocus() ? dest : dest < 0 ? -(slideCount % perPage || perPage) : slideCount;\n          } else if (options.rewind) {\n            dest = dest < 0 ? end : 0;\n          } else {\n            dest = -1;\n          }\n        }\n      } else {\n        if (!incremental && dest !== from) {\n          dest = perMove ? dest : toIndex(toPage(from) + (dest < from ? -1 : 1));\n        }\n      }\n    } else {\n      dest = -1;\n    }\n    return dest;\n  }\n  function getEnd() {\n    let end = slideCount - perPage;\n    if (hasFocus() || isLoop && perMove) {\n      end = slideCount - 1;\n    }\n    return max(end, 0);\n  }\n  function loop(index) {\n    if (isLoop) {\n      return isEnough() ? index % slideCount + (index < 0 ? slideCount : 0) : -1;\n    }\n    return index;\n  }\n  function toIndex(page) {\n    return clamp(hasFocus() ? page : perPage * page, 0, getEnd());\n  }\n  function toPage(index) {\n    if (!hasFocus()) {\n      index = between(index, slideCount - perPage, slideCount - 1) ? slideCount - 1 : index;\n      index = floor(index / perPage);\n    }\n    return index;\n  }\n  function toDest(destination) {\n    const closest = Move.toIndex(destination);\n    return isSlide ? clamp(closest, 0, getEnd()) : closest;\n  }\n  function setIndex(index) {\n    if (index !== currIndex) {\n      prevIndex = currIndex;\n      currIndex = index;\n    }\n  }\n  function getIndex(prev) {\n    return prev ? prevIndex : currIndex;\n  }\n  function hasFocus() {\n    return !isUndefined(options.focus) || options.isNavigation;\n  }\n  return {\n    mount,\n    go,\n    scroll,\n    getNext,\n    getPrev,\n    getAdjacent,\n    getEnd,\n    setIndex,\n    getIndex,\n    toIndex,\n    toPage,\n    toDest,\n    hasFocus\n  };\n}\n\nconst XML_NAME_SPACE = \"http://www.w3.org/2000/svg\";\nconst PATH = \"m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z\";\nconst SIZE = 40;\n\nfunction Arrows(Splide2, Components2, options) {\n  const { on, bind, emit } = EventInterface(Splide2);\n  const { classes, i18n } = options;\n  const { Elements, Controller } = Components2;\n  let wrapper = Elements.arrows;\n  let prev = Elements.prev;\n  let next = Elements.next;\n  let created;\n  const arrows = {};\n  function mount() {\n    init();\n    on(EVENT_UPDATED, init);\n  }\n  function init() {\n    if (options.arrows) {\n      if (!prev || !next) {\n        createArrows();\n      }\n    }\n    if (prev && next) {\n      if (!arrows.prev) {\n        const { id } = Elements.track;\n        setAttribute(prev, ARIA_CONTROLS, id);\n        setAttribute(next, ARIA_CONTROLS, id);\n        arrows.prev = prev;\n        arrows.next = next;\n        listen();\n        emit(EVENT_ARROWS_MOUNTED, prev, next);\n      } else {\n        display(wrapper, options.arrows === false ? \"none\" : \"\");\n      }\n    }\n  }\n  function destroy() {\n    if (created) {\n      remove(wrapper);\n    } else {\n      removeAttribute(prev, ALL_ATTRIBUTES);\n      removeAttribute(next, ALL_ATTRIBUTES);\n    }\n  }\n  function listen() {\n    const { go } = Controller;\n    on([EVENT_MOUNTED, EVENT_MOVED, EVENT_UPDATED, EVENT_REFRESH, EVENT_SCROLLED], update);\n    bind(next, \"click\", () => {\n      go(\">\", true);\n    });\n    bind(prev, \"click\", () => {\n      go(\"<\", true);\n    });\n  }\n  function createArrows() {\n    wrapper = create(\"div\", classes.arrows);\n    prev = createArrow(true);\n    next = createArrow(false);\n    created = true;\n    append(wrapper, [prev, next]);\n    before(wrapper, child(options.arrows === \"slider\" && Elements.slider || Splide2.root));\n  }\n  function createArrow(prev2) {\n    const arrow = `<button class=\"${classes.arrow} ${prev2 ? classes.prev : classes.next}\" type=\"button\"><svg xmlns=\"${XML_NAME_SPACE}\" viewBox=\"0 0 ${SIZE} ${SIZE}\" width=\"${SIZE}\" height=\"${SIZE}\"><path d=\"${options.arrowPath || PATH}\" />`;\n    return parseHtml(arrow);\n  }\n  function update() {\n    const index = Splide2.index;\n    const prevIndex = Controller.getPrev();\n    const nextIndex = Controller.getNext();\n    const prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n    const nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n    prev.disabled = prevIndex < 0;\n    next.disabled = nextIndex < 0;\n    setAttribute(prev, ARIA_LABEL, prevLabel);\n    setAttribute(next, ARIA_LABEL, nextLabel);\n    emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);\n  }\n  return {\n    arrows,\n    mount,\n    destroy\n  };\n}\n\nconst INTERVAL_DATA_ATTRIBUTE = `${DATA_ATTRIBUTE}-interval`;\n\nfunction Autoplay(Splide2, Components2, options) {\n  const { on, bind, emit } = EventInterface(Splide2);\n  const interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, \">\"), update);\n  const { isPaused } = interval;\n  const { Elements } = Components2;\n  let hovered;\n  let focused;\n  let paused;\n  function mount() {\n    const { autoplay } = options;\n    if (autoplay) {\n      initButton(true);\n      initButton(false);\n      listen();\n      if (autoplay !== \"pause\") {\n        play();\n      }\n    }\n  }\n  function initButton(forPause) {\n    const prop = forPause ? \"pause\" : \"play\";\n    const button = Elements[prop];\n    if (button) {\n      setAttribute(button, ARIA_CONTROLS, Elements.track.id);\n      setAttribute(button, ARIA_LABEL, options.i18n[prop]);\n      bind(button, \"click\", forPause ? pause : play);\n    }\n  }\n  function listen() {\n    const { root } = Elements;\n    if (options.pauseOnHover) {\n      bind(root, \"mouseenter mouseleave\", (e) => {\n        hovered = e.type === \"mouseenter\";\n        autoToggle();\n      });\n    }\n    if (options.pauseOnFocus) {\n      bind(root, \"focusin focusout\", (e) => {\n        focused = e.type === \"focusin\";\n        autoToggle();\n      });\n    }\n    on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);\n    on(EVENT_MOVE, updateInterval);\n  }\n  function play() {\n    if (isPaused() && Components2.Slides.isEnough()) {\n      interval.start(!options.resetProgress);\n      focused = hovered = paused = false;\n      emit(EVENT_AUTOPLAY_PLAY);\n    }\n  }\n  function pause(manual = true) {\n    if (!isPaused()) {\n      interval.pause();\n      emit(EVENT_AUTOPLAY_PAUSE);\n    }\n    paused = manual;\n  }\n  function autoToggle() {\n    if (!paused) {\n      if (!hovered && !focused) {\n        play();\n      } else {\n        pause(false);\n      }\n    }\n  }\n  function update(rate) {\n    const { bar } = Elements;\n    bar && style(bar, \"width\", `${rate * 100}%`);\n    emit(EVENT_AUTOPLAY_PLAYING, rate);\n  }\n  function updateInterval() {\n    const Slide = Components2.Slides.getAt(Splide2.index);\n    interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);\n  }\n  return {\n    mount,\n    destroy: interval.cancel,\n    play,\n    pause,\n    isPaused\n  };\n}\n\nfunction Cover(Splide2, Components2, options) {\n  const { on } = EventInterface(Splide2);\n  function mount() {\n    if (options.cover) {\n      on(EVENT_LAZYLOAD_LOADED, (img, Slide) => {\n        toggle(true, img, Slide);\n      });\n      on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply.bind(null, true));\n    }\n  }\n  function destroy() {\n    apply(false);\n  }\n  function apply(cover) {\n    Components2.Slides.forEach((Slide) => {\n      const img = child(Slide.container || Slide.slide, \"img\");\n      if (img && img.src) {\n        toggle(cover, img, Slide);\n      }\n    });\n  }\n  function toggle(cover, img, Slide) {\n    Slide.style(\"background\", cover ? `center/cover no-repeat url(\"${img.src}\")` : \"\", true);\n    display(img, cover ? \"none\" : \"\");\n  }\n  return {\n    mount,\n    destroy\n  };\n}\n\nconst BOUNCE_DIFF_THRESHOLD = 10;\nconst BOUNCE_DURATION = 600;\nconst FRICTION_FACTOR = 0.6;\nconst BASE_VELOCITY = 1.5;\nconst MIN_DURATION = 800;\n\nfunction Scroll(Splide2, Components2, options) {\n  const { on, emit } = EventInterface(Splide2);\n  const { Move } = Components2;\n  const { getPosition, getLimit, exceededLimit } = Move;\n  let interval;\n  let scrollCallback;\n  function mount() {\n    on(EVENT_MOVE, clear);\n    on([EVENT_UPDATED, EVENT_REFRESH], cancel);\n  }\n  function scroll(destination, duration, callback, suppressConstraint) {\n    const start = getPosition();\n    let friction = 1;\n    duration = duration || computeDuration(abs(destination - start));\n    scrollCallback = callback;\n    clear();\n    interval = RequestInterval(duration, onScrolled, (rate) => {\n      const position = getPosition();\n      const target = start + (destination - start) * easing(rate);\n      const diff = (target - getPosition()) * friction;\n      Move.translate(position + diff);\n      if (Splide2.is(SLIDE) && !suppressConstraint && exceededLimit()) {\n        friction *= FRICTION_FACTOR;\n        if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {\n          bounce(exceededLimit(false));\n        }\n      }\n    }, 1);\n    emit(EVENT_SCROLL);\n    interval.start();\n  }\n  function bounce(backwards) {\n    scroll(getLimit(!backwards), BOUNCE_DURATION, null, true);\n  }\n  function onScrolled() {\n    const position = getPosition();\n    const index = Move.toIndex(position);\n    if (!between(index, 0, Splide2.length - 1)) {\n      Move.translate(Move.shift(position, index > 0), true);\n    }\n    scrollCallback && scrollCallback();\n    emit(EVENT_SCROLLED);\n  }\n  function computeDuration(distance) {\n    return max(distance / BASE_VELOCITY, MIN_DURATION);\n  }\n  function clear() {\n    if (interval) {\n      interval.cancel();\n    }\n  }\n  function cancel() {\n    if (interval && !interval.isPaused()) {\n      clear();\n      onScrolled();\n    }\n  }\n  function easing(t) {\n    const { easingFunc } = options;\n    return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);\n  }\n  return {\n    mount,\n    destroy: clear,\n    scroll,\n    cancel\n  };\n}\n\nconst SCROLL_LISTENER_OPTIONS = { passive: false, capture: true };\n\nconst FRICTION = 5;\nconst LOG_INTERVAL = 200;\nconst POINTER_DOWN_EVENTS = \"touchstart mousedown\";\nconst POINTER_MOVE_EVENTS = \"touchmove mousemove\";\nconst POINTER_UP_EVENTS = \"touchend touchcancel mouseup\";\n\nfunction Drag(Splide2, Components2, options) {\n  const { on, emit, bind, unbind } = EventInterface(Splide2);\n  const { Move, Scroll, Controller } = Components2;\n  const { track } = Components2.Elements;\n  const { resolve, orient } = Components2.Direction;\n  const { getPosition, exceededLimit } = Move;\n  let basePosition;\n  let baseEvent;\n  let prevBaseEvent;\n  let lastEvent;\n  let isFree;\n  let dragging;\n  let hasExceeded = false;\n  let clickPrevented;\n  let disabled;\n  let target;\n  function mount() {\n    bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);\n    bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);\n    bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);\n    bind(track, \"click\", onClick, { capture: true });\n    bind(track, \"dragstart\", prevent);\n    on([EVENT_MOUNTED, EVENT_UPDATED], init);\n  }\n  function init() {\n    const { drag } = options;\n    disable(!drag);\n    isFree = drag === \"free\";\n  }\n  function onPointerDown(e) {\n    if (!disabled) {\n      const { noDrag } = options;\n      const isTouch = isTouchEvent(e);\n      const isDraggable = !noDrag || !matches(e.target, noDrag);\n      clickPrevented = false;\n      if (isDraggable && (isTouch || !e.button)) {\n        if (!Move.isBusy()) {\n          target = isTouch ? track : window;\n          prevBaseEvent = null;\n          lastEvent = null;\n          bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);\n          bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);\n          Move.cancel();\n          Scroll.cancel();\n          save(e);\n        } else {\n          prevent(e, true);\n        }\n      }\n    }\n  }\n  function onPointerMove(e) {\n    if (!lastEvent) {\n      emit(EVENT_DRAG);\n    }\n    lastEvent = e;\n    if (e.cancelable) {\n      const diff = coordOf(e) - coordOf(baseEvent);\n      if (dragging) {\n        Move.translate(basePosition + constrain(diff));\n        const expired = timeOf(e) - timeOf(baseEvent) > LOG_INTERVAL;\n        const exceeded = hasExceeded !== (hasExceeded = exceededLimit());\n        if (expired || exceeded) {\n          save(e);\n        }\n        emit(EVENT_DRAGGING);\n        clickPrevented = true;\n        prevent(e);\n      } else {\n        let { dragMinThreshold: thresholds } = options;\n        thresholds = isObject(thresholds) ? thresholds : { mouse: 0, touch: +thresholds || 10 };\n        dragging = abs(diff) > (isTouchEvent(e) ? thresholds.touch : thresholds.mouse);\n        if (isSliderDirection()) {\n          prevent(e);\n        }\n      }\n    }\n  }\n  function onPointerUp(e) {\n    unbind(target, POINTER_MOVE_EVENTS, onPointerMove);\n    unbind(target, POINTER_UP_EVENTS, onPointerUp);\n    const { index } = Splide2;\n    if (lastEvent) {\n      if (dragging || e.cancelable && isSliderDirection()) {\n        const velocity = computeVelocity(e);\n        const destination = computeDestination(velocity);\n        if (isFree) {\n          Controller.scroll(destination);\n        } else if (Splide2.is(FADE)) {\n          Controller.go(index + orient(sign(velocity)));\n        } else {\n          Controller.go(Controller.toDest(destination), true);\n        }\n        prevent(e);\n      }\n      emit(EVENT_DRAGGED);\n    } else {\n      if (!isFree && getPosition() !== Move.toPosition(index)) {\n        Controller.go(index, true);\n      }\n    }\n    dragging = false;\n  }\n  function save(e) {\n    prevBaseEvent = baseEvent;\n    baseEvent = e;\n    basePosition = getPosition();\n  }\n  function onClick(e) {\n    if (!disabled && clickPrevented) {\n      prevent(e, true);\n    }\n  }\n  function isSliderDirection() {\n    const diffX = abs(coordOf(lastEvent) - coordOf(baseEvent));\n    const diffY = abs(coordOf(lastEvent, true) - coordOf(baseEvent, true));\n    return diffX > diffY;\n  }\n  function computeVelocity(e) {\n    if (Splide2.is(LOOP) || !hasExceeded) {\n      const base = baseEvent === lastEvent && prevBaseEvent || baseEvent;\n      const diffCoord = coordOf(lastEvent) - coordOf(base);\n      const diffTime = timeOf(e) - timeOf(base);\n      const isFlick = timeOf(e) - timeOf(lastEvent) < LOG_INTERVAL;\n      if (diffTime && isFlick) {\n        return diffCoord / diffTime;\n      }\n    }\n    return 0;\n  }\n  function computeDestination(velocity) {\n    return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));\n  }\n  function coordOf(e, orthogonal) {\n    return (isTouchEvent(e) ? e.touches[0] : e)[`page${resolve(orthogonal ? \"Y\" : \"X\")}`];\n  }\n  function timeOf(e) {\n    return e.timeStamp;\n  }\n  function constrain(diff) {\n    return diff / (hasExceeded && Splide2.is(SLIDE) ? FRICTION : 1);\n  }\n  function isTouchEvent(e) {\n    return typeof TouchEvent !== \"undefined\" && e instanceof TouchEvent;\n  }\n  function isDragging() {\n    return dragging;\n  }\n  function disable(value) {\n    disabled = value;\n  }\n  return {\n    mount,\n    disable,\n    isDragging\n  };\n}\n\nconst IE_ARROW_KEYS = [\"Left\", \"Right\", \"Up\", \"Down\"];\nconst KEYBOARD_EVENT = \"keydown\";\nfunction Keyboard(Splide2, Components2, options) {\n  const { on, bind, unbind } = EventInterface(Splide2);\n  const { root } = Splide2;\n  const { resolve } = Components2.Direction;\n  let target;\n  let disabled;\n  function mount() {\n    init();\n    on(EVENT_UPDATED, onUpdated);\n    on(EVENT_MOVE, onMove);\n  }\n  function init() {\n    const { keyboard } = options;\n    if (keyboard) {\n      if (keyboard === \"focused\") {\n        target = root;\n        setAttribute(root, TAB_INDEX, 0);\n      } else {\n        target = window;\n      }\n      bind(target, KEYBOARD_EVENT, onKeydown);\n    }\n  }\n  function destroy() {\n    unbind(target, KEYBOARD_EVENT);\n    if (isHTMLElement(target)) {\n      removeAttribute(target, TAB_INDEX);\n    }\n  }\n  function disable(value) {\n    disabled = value;\n  }\n  function onMove() {\n    const _disabled = disabled;\n    disabled = true;\n    nextTick(() => {\n      disabled = _disabled;\n    });\n  }\n  function onUpdated() {\n    destroy();\n    init();\n  }\n  function onKeydown(e) {\n    if (!disabled) {\n      const { key } = e;\n      const normalizedKey = includes(IE_ARROW_KEYS, key) ? `Arrow${key}` : key;\n      if (normalizedKey === resolve(\"ArrowLeft\")) {\n        Splide2.go(\"<\");\n      } else if (normalizedKey === resolve(\"ArrowRight\")) {\n        Splide2.go(\">\");\n      }\n    }\n  }\n  return {\n    mount,\n    destroy,\n    disable\n  };\n}\n\nconst SRC_DATA_ATTRIBUTE = `${DATA_ATTRIBUTE}-lazy`;\nconst SRCSET_DATA_ATTRIBUTE = `${SRC_DATA_ATTRIBUTE}-srcset`;\nconst IMAGE_SELECTOR = `[${SRC_DATA_ATTRIBUTE}], [${SRCSET_DATA_ATTRIBUTE}]`;\n\nfunction LazyLoad(Splide2, Components2, options) {\n  const { on, off, bind, emit } = EventInterface(Splide2);\n  const isSequential = options.lazyLoad === \"sequential\";\n  let images = [];\n  let index = 0;\n  function mount() {\n    if (options.lazyLoad) {\n      init();\n      on(EVENT_REFRESH, refresh);\n      if (!isSequential) {\n        on([EVENT_MOUNTED, EVENT_REFRESH, EVENT_MOVED, EVENT_SCROLLED], observe);\n      }\n    }\n  }\n  function refresh() {\n    destroy();\n    init();\n  }\n  function init() {\n    Components2.Slides.forEach((_Slide) => {\n      queryAll(_Slide.slide, IMAGE_SELECTOR).forEach((_img) => {\n        const src = getAttribute(_img, SRC_DATA_ATTRIBUTE);\n        const srcset = getAttribute(_img, SRCSET_DATA_ATTRIBUTE);\n        if (src !== _img.src || srcset !== _img.srcset) {\n          const className = options.classes.spinner;\n          const parent = _img.parentElement;\n          const _spinner = child(parent, `.${className}`) || create(\"span\", className, parent);\n          setAttribute(_spinner, ROLE, \"presentation\");\n          images.push({ _img, _Slide, src, srcset, _spinner });\n          !_img.src && display(_img, \"none\");\n        }\n      });\n    });\n    if (isSequential) {\n      loadNext();\n    }\n  }\n  function destroy() {\n    index = 0;\n    images = [];\n  }\n  function observe() {\n    images = images.filter((data) => {\n      const distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;\n      if (data._Slide.isWithin(Splide2.index, distance)) {\n        return load(data);\n      }\n      return true;\n    });\n    if (!images.length) {\n      off(EVENT_MOVED);\n    }\n  }\n  function load(data) {\n    const { _img } = data;\n    addClass(data._Slide.slide, CLASS_LOADING);\n    bind(_img, \"load error\", (e) => {\n      onLoad(data, e.type === \"error\");\n    });\n    [\"src\", \"srcset\"].forEach((name) => {\n      if (data[name]) {\n        setAttribute(_img, name, data[name]);\n        removeAttribute(_img, name === \"src\" ? SRC_DATA_ATTRIBUTE : SRCSET_DATA_ATTRIBUTE);\n      }\n    });\n  }\n  function onLoad(data, error) {\n    const { _Slide } = data;\n    removeClass(_Slide.slide, CLASS_LOADING);\n    if (!error) {\n      remove(data._spinner);\n      display(data._img, \"\");\n      emit(EVENT_LAZYLOAD_LOADED, data._img, _Slide);\n      emit(EVENT_RESIZE);\n    }\n    if (isSequential) {\n      loadNext();\n    }\n  }\n  function loadNext() {\n    if (index < images.length) {\n      load(images[index++]);\n    }\n  }\n  return {\n    mount,\n    destroy\n  };\n}\n\nfunction Pagination(Splide2, Components2, options) {\n  const { on, emit, bind, unbind } = EventInterface(Splide2);\n  const { Slides, Elements, Controller } = Components2;\n  const { hasFocus, getIndex } = Controller;\n  const items = [];\n  let list;\n  function mount() {\n    init();\n    on([EVENT_UPDATED, EVENT_REFRESH], init);\n    on([EVENT_MOVE, EVENT_SCROLLED], update);\n  }\n  function init() {\n    destroy();\n    if (options.pagination && Slides.isEnough()) {\n      createPagination();\n      emit(EVENT_PAGINATION_MOUNTED, { list, items }, getAt(Splide2.index));\n      update();\n    }\n  }\n  function destroy() {\n    if (list) {\n      remove(list);\n      items.forEach((item) => {\n        unbind(item.button, \"click\");\n      });\n      empty(items);\n      list = null;\n    }\n  }\n  function createPagination() {\n    const { length } = Splide2;\n    const { classes, i18n, perPage } = options;\n    const parent = options.pagination === \"slider\" && Elements.slider || Elements.root;\n    const max = hasFocus() ? length : ceil(length / perPage);\n    list = create(\"ul\", classes.pagination, parent);\n    for (let i = 0; i < max; i++) {\n      const li = create(\"li\", null, list);\n      const button = create(\"button\", { class: classes.page, type: \"button\" }, li);\n      const controls = Slides.getIn(i).map((Slide) => Slide.slide.id);\n      const text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;\n      bind(button, \"click\", onClick.bind(null, i));\n      setAttribute(button, ARIA_CONTROLS, controls.join(\" \"));\n      setAttribute(button, ARIA_LABEL, format(text, i + 1));\n      items.push({ li, button, page: i });\n    }\n  }\n  function onClick(page) {\n    Controller.go(`>${page}`, true, () => {\n      const Slide = Slides.getAt(Controller.toIndex(page));\n      Slide && focus(Slide.slide);\n    });\n  }\n  function getAt(index) {\n    return items[Controller.toPage(index)];\n  }\n  function update() {\n    const prev = getAt(getIndex(true));\n    const curr = getAt(getIndex());\n    if (prev) {\n      removeClass(prev.button, CLASS_ACTIVE);\n      removeAttribute(prev.button, ARIA_CURRENT);\n    }\n    if (curr) {\n      addClass(curr.button, CLASS_ACTIVE);\n      setAttribute(curr.button, ARIA_CURRENT, true);\n    }\n    emit(EVENT_PAGINATION_UPDATED, { list, items }, prev, curr);\n  }\n  return {\n    items,\n    mount,\n    destroy,\n    getAt,\n    update\n  };\n}\n\nconst TRIGGER_KEYS = [\" \", \"Enter\", \"Spacebar\"];\nfunction Sync(Splide2, Components2, options) {\n  const { list } = Components2.Elements;\n  const events = [];\n  function mount() {\n    Splide2.splides.forEach((target) => {\n      !target.isParent && sync(target.splide);\n    });\n    if (options.isNavigation) {\n      navigate();\n    }\n  }\n  function destroy() {\n    removeAttribute(list, ALL_ATTRIBUTES);\n    events.forEach((event) => {\n      event.destroy();\n    });\n    empty(events);\n  }\n  function remount() {\n    destroy();\n    mount();\n  }\n  function sync(splide) {\n    [Splide2, splide].forEach((instance) => {\n      const event = EventInterface(instance);\n      const target = instance === Splide2 ? splide : Splide2;\n      event.on(EVENT_MOVE, (index, prev, dest) => {\n        target.go(target.is(LOOP) ? dest : index);\n      });\n      events.push(event);\n    });\n  }\n  function navigate() {\n    const event = EventInterface(Splide2);\n    const { on } = event;\n    on(EVENT_CLICK, onClick);\n    on(EVENT_SLIDE_KEYDOWN, onKeydown);\n    on([EVENT_MOUNTED, EVENT_UPDATED], update);\n    setAttribute(list, ROLE, \"menu\");\n    events.push(event);\n    event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);\n  }\n  function update() {\n    setAttribute(list, ARIA_ORIENTATION, options.direction !== TTB ? \"horizontal\" : null);\n  }\n  function onClick(Slide) {\n    Splide2.go(Slide.index);\n  }\n  function onKeydown(Slide, e) {\n    if (includes(TRIGGER_KEYS, e.key)) {\n      onClick(Slide);\n      prevent(e);\n    }\n  }\n  return {\n    mount,\n    destroy,\n    remount\n  };\n}\n\nfunction Wheel(Splide2, Components2, options) {\n  const { bind } = EventInterface(Splide2);\n  function mount() {\n    if (options.wheel) {\n      bind(Components2.Elements.track, \"wheel\", onWheel, SCROLL_LISTENER_OPTIONS);\n    }\n  }\n  function onWheel(e) {\n    if (e.cancelable) {\n      const { deltaY } = e;\n      if (deltaY) {\n        const backwards = deltaY < 0;\n        Splide2.go(backwards ? \"<\" : \">\");\n        shouldPrevent(backwards) && prevent(e);\n      }\n    }\n  }\n  function shouldPrevent(backwards) {\n    return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;\n  }\n  return {\n    mount\n  };\n}\n\nvar ComponentConstructors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Options: Options,\n  Direction: Direction,\n  Elements: Elements,\n  Slides: Slides,\n  Layout: Layout,\n  Clones: Clones,\n  Move: Move,\n  Controller: Controller,\n  Arrows: Arrows,\n  Autoplay: Autoplay,\n  Cover: Cover,\n  Scroll: Scroll,\n  Drag: Drag,\n  Keyboard: Keyboard,\n  LazyLoad: LazyLoad,\n  Pagination: Pagination,\n  Sync: Sync,\n  Wheel: Wheel\n});\n\nconst I18N = {\n  prev: \"Previous slide\",\n  next: \"Next slide\",\n  first: \"Go to first slide\",\n  last: \"Go to last slide\",\n  slideX: \"Go to slide %s\",\n  pageX: \"Go to page %s\",\n  play: \"Start autoplay\",\n  pause: \"Pause autoplay\"\n};\n\nconst DEFAULTS = {\n  type: \"slide\",\n  speed: 400,\n  waitForTransition: true,\n  perPage: 1,\n  cloneStatus: true,\n  arrows: true,\n  pagination: true,\n  interval: 5e3,\n  pauseOnHover: true,\n  pauseOnFocus: true,\n  resetProgress: true,\n  keyboard: true,\n  easing: \"cubic-bezier(0.25, 1, 0.5, 1)\",\n  drag: true,\n  direction: \"ltr\",\n  slideFocus: true,\n  trimSpace: true,\n  focusableNodes: \"a, button, textarea, input, select, iframe\",\n  classes: CLASSES,\n  i18n: I18N\n};\n\nfunction Fade(Splide2, Components2, options) {\n  const { on } = EventInterface(Splide2);\n  function mount() {\n    on([EVENT_MOUNTED, EVENT_REFRESH], () => {\n      nextTick(() => {\n        Components2.Slides.style(\"transition\", `opacity ${options.speed}ms ${options.easing}`);\n      });\n    });\n  }\n  function start(index, done) {\n    const { track } = Components2.Elements;\n    style(track, \"height\", unit(rect(track).height));\n    nextTick(() => {\n      done();\n      style(track, \"height\", \"\");\n    });\n  }\n  return {\n    mount,\n    start,\n    cancel: noop\n  };\n}\n\nfunction Slide(Splide2, Components2, options) {\n  const { bind } = EventInterface(Splide2);\n  const { Move, Controller } = Components2;\n  const { list } = Components2.Elements;\n  let endCallback;\n  function mount() {\n    bind(list, \"transitionend\", (e) => {\n      if (e.target === list && endCallback) {\n        cancel();\n        endCallback();\n      }\n    });\n  }\n  function start(index, done) {\n    const destination = Move.toPosition(index, true);\n    const position = Move.getPosition();\n    const speed = getSpeed(index);\n    if (abs(destination - position) >= 1 && speed >= 1) {\n      apply(`transform ${speed}ms ${options.easing}`);\n      Move.translate(destination, true);\n      endCallback = done;\n    } else {\n      Move.jump(index);\n      done();\n    }\n  }\n  function cancel() {\n    apply(\"\");\n  }\n  function getSpeed(index) {\n    const { rewindSpeed } = options;\n    if (Splide2.is(SLIDE) && rewindSpeed) {\n      const prev = Controller.getIndex(true);\n      const end = Controller.getEnd();\n      if (prev === 0 && index >= end || prev >= end && index === 0) {\n        return rewindSpeed;\n      }\n    }\n    return options.speed;\n  }\n  function apply(transition) {\n    style(list, \"transition\", transition);\n  }\n  return {\n    mount,\n    start,\n    cancel\n  };\n}\n\nconst _Splide = class {\n  constructor(target, options) {\n    this.event = EventBus();\n    this.Components = {};\n    this.state = State(CREATED);\n    this.splides = [];\n    this._options = {};\n    this._Extensions = {};\n    const root = isString(target) ? query(document, target) : target;\n    assert(root, `${root} is invalid.`);\n    this.root = root;\n    merge(DEFAULTS, _Splide.defaults);\n    merge(merge(this._options, DEFAULTS), options || {});\n  }\n  mount(Extensions, Transition) {\n    const { state, Components: Components2 } = this;\n    assert(state.is([CREATED, DESTROYED]), \"Already mounted!\");\n    state.set(CREATED);\n    this._Components = Components2;\n    this._Transition = Transition || this._Transition || (this.is(FADE) ? Fade : Slide);\n    this._Extensions = Extensions || this._Extensions;\n    const Constructors = assign({}, ComponentConstructors, this._Extensions, { Transition: this._Transition });\n    forOwn(Constructors, (Component, key) => {\n      const component = Component(this, Components2, this._options);\n      Components2[key] = component;\n      component.setup && component.setup();\n    });\n    forOwn(Components2, (component) => {\n      component.mount && component.mount();\n    });\n    this.emit(EVENT_MOUNTED);\n    addClass(this.root, CLASS_INITIALIZED);\n    state.set(IDLE);\n    this.emit(EVENT_READY);\n    return this;\n  }\n  sync(splide) {\n    this.splides.push({ splide });\n    splide.splides.push({ splide: this, isParent: true });\n    if (this.state.is(IDLE)) {\n      this._Components.Sync.remount();\n      splide.Components.Sync.remount();\n    }\n    return this;\n  }\n  go(control) {\n    this._Components.Controller.go(control);\n    return this;\n  }\n  on(events, callback) {\n    this.event.on(events, callback, null, DEFAULT_USER_EVENT_PRIORITY);\n    return this;\n  }\n  off(events) {\n    this.event.off(events);\n    return this;\n  }\n  emit(event) {\n    this.event.emit(event, ...slice(arguments, 1));\n    return this;\n  }\n  add(slides, index) {\n    this._Components.Slides.add(slides, index);\n    return this;\n  }\n  remove(matcher) {\n    this._Components.Slides.remove(matcher);\n    return this;\n  }\n  is(type) {\n    return this._options.type === type;\n  }\n  refresh() {\n    this.emit(EVENT_REFRESH);\n    return this;\n  }\n  destroy(completely = true) {\n    const { event, state } = this;\n    if (state.is(CREATED)) {\n      event.on(EVENT_READY, this.destroy.bind(this, completely), this);\n    } else {\n      forOwn(this._Components, (component) => {\n        component.destroy && component.destroy(completely);\n      }, true);\n      event.emit(EVENT_DESTROY);\n      event.destroy();\n      completely && empty(this.splides);\n      state.set(DESTROYED);\n    }\n    return this;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    const { _options } = this;\n    merge(_options, options);\n    if (!this.state.is(CREATED)) {\n      this.emit(EVENT_UPDATED, _options);\n    }\n  }\n  get length() {\n    return this._Components.Slides.getLength(true);\n  }\n  get index() {\n    return this._Components.Controller.getIndex();\n  }\n};\nlet Splide = _Splide;\nSplide.defaults = {};\nSplide.STATES = STATES;\n\nconst CLASS_RENDERED = \"is-rendered\";\n\nconst RENDERER_DEFAULT_CONFIG = {\n  listTag: \"ul\",\n  slideTag: \"li\"\n};\n\nclass Style {\n  constructor(id, options) {\n    this.styles = {};\n    this.id = id;\n    this.options = options;\n  }\n  rule(selector, prop, value, breakpoint) {\n    breakpoint = breakpoint || \"default\";\n    const selectors = this.styles[breakpoint] = this.styles[breakpoint] || {};\n    const styles = selectors[selector] = selectors[selector] || {};\n    styles[prop] = value;\n  }\n  build() {\n    let css = \"\";\n    if (this.styles.default) {\n      css += this.buildSelectors(this.styles.default);\n    }\n    Object.keys(this.styles).sort((n, m) => this.options.mediaQuery === \"min\" ? +n - +m : +m - +n).forEach((breakpoint) => {\n      if (breakpoint !== \"default\") {\n        css += `@media screen and (max-width: ${breakpoint}px) {`;\n        css += this.buildSelectors(this.styles[breakpoint]);\n        css += `}`;\n      }\n    });\n    return css;\n  }\n  buildSelectors(selectors) {\n    let css = \"\";\n    forOwn(selectors, (styles, selector) => {\n      selector = `#${this.id} ${selector}`.trim();\n      css += `${selector} {`;\n      forOwn(styles, (value, prop) => {\n        if (value || value === 0) {\n          css += `${prop}: ${value};`;\n        }\n      });\n      css += \"}\";\n    });\n    return css;\n  }\n}\n\nclass SplideRenderer {\n  constructor(contents, options, config, defaults) {\n    this.slides = [];\n    this.options = {};\n    this.breakpoints = [];\n    merge(DEFAULTS, defaults || {});\n    merge(merge(this.options, DEFAULTS), options || {});\n    this.contents = contents;\n    this.config = assign({}, RENDERER_DEFAULT_CONFIG, config || {});\n    this.id = this.config.id || uniqueId(\"splide\");\n    this.Style = new Style(this.id, this.options);\n    this.Direction = Direction(null, null, this.options);\n    assert(this.contents.length, \"Provide at least 1 content.\");\n    this.init();\n  }\n  static clean(splide) {\n    const { on } = EventInterface(splide);\n    const { root } = splide;\n    const clones = queryAll(root, `.${CLASS_CLONE}`);\n    on(EVENT_MOUNTED, () => {\n      remove(child(root, \"style\"));\n    });\n    remove(clones);\n  }\n  init() {\n    this.parseBreakpoints();\n    this.initSlides();\n    this.registerRootStyles();\n    this.registerTrackStyles();\n    this.registerSlideStyles();\n    this.registerListStyles();\n  }\n  initSlides() {\n    push(this.slides, this.contents.map((content, index) => {\n      content = isString(content) ? { html: content } : content;\n      content.styles = content.styles || {};\n      content.attrs = content.attrs || {};\n      this.cover(content);\n      const classes = `${this.options.classes.slide} ${index === 0 ? CLASS_ACTIVE : \"\"}`;\n      assign(content.attrs, {\n        class: `${classes} ${content.attrs.class || \"\"}`.trim(),\n        style: this.buildStyles(content.styles)\n      });\n      return content;\n    }));\n    if (this.isLoop()) {\n      this.generateClones(this.slides);\n    }\n  }\n  registerRootStyles() {\n    this.breakpoints.forEach(([width, options]) => {\n      this.Style.rule(\" \", \"max-width\", unit(options.width), width);\n    });\n  }\n  registerTrackStyles() {\n    const { Style: Style2 } = this;\n    const selector = `.${CLASS_TRACK}`;\n    this.breakpoints.forEach(([width, options]) => {\n      Style2.rule(selector, this.resolve(\"paddingLeft\"), this.cssPadding(options, false), width);\n      Style2.rule(selector, this.resolve(\"paddingRight\"), this.cssPadding(options, true), width);\n      Style2.rule(selector, \"height\", this.cssTrackHeight(options), width);\n    });\n  }\n  registerListStyles() {\n    const { Style: Style2 } = this;\n    const selector = `.${CLASS_LIST}`;\n    this.breakpoints.forEach(([width, options]) => {\n      Style2.rule(selector, \"transform\", this.buildTranslate(options), width);\n      if (!this.cssSlideHeight(options)) {\n        Style2.rule(selector, \"aspect-ratio\", this.cssAspectRatio(options), width);\n      }\n    });\n  }\n  registerSlideStyles() {\n    const { Style: Style2 } = this;\n    const selector = `.${CLASS_SLIDE}`;\n    this.breakpoints.forEach(([width, options]) => {\n      Style2.rule(selector, \"width\", this.cssSlideWidth(options), width);\n      Style2.rule(selector, \"height\", this.cssSlideHeight(options) || \"100%\", width);\n      Style2.rule(selector, this.resolve(\"marginRight\"), unit(options.gap) || \"0px\", width);\n      Style2.rule(`${selector} > img`, \"display\", options.cover ? \"none\" : \"inline\", width);\n    });\n  }\n  buildTranslate(options) {\n    const { resolve, orient } = this.Direction;\n    const values = [];\n    values.push(this.cssOffsetClones(options));\n    values.push(this.cssOffsetGaps(options));\n    if (this.isCenter(options)) {\n      values.push(this.buildCssValue(orient(-50), \"%\"));\n      values.push(...this.cssOffsetCenter(options));\n    }\n    return values.filter(Boolean).map((value) => `translate${resolve(\"X\")}(${value})`).join(\" \");\n  }\n  cssOffsetClones(options) {\n    const { resolve, orient } = this.Direction;\n    const cloneCount = this.getCloneCount();\n    if (this.isFixedWidth(options)) {\n      const { value, unit: unit2 } = this.parseCssValue(options[resolve(\"fixedWidth\")]);\n      return this.buildCssValue(orient(value) * cloneCount, unit2);\n    }\n    const percent = 100 * cloneCount / options.perPage;\n    return `${orient(percent)}%`;\n  }\n  cssOffsetCenter(options) {\n    const { resolve, orient } = this.Direction;\n    if (this.isFixedWidth(options)) {\n      const { value, unit: unit2 } = this.parseCssValue(options[resolve(\"fixedWidth\")]);\n      return [this.buildCssValue(orient(value / 2), unit2)];\n    }\n    const values = [];\n    const { perPage, gap } = options;\n    values.push(`${orient(50 / perPage)}%`);\n    if (gap) {\n      const { value, unit: unit2 } = this.parseCssValue(gap);\n      const gapOffset = (value / perPage - value) / 2;\n      values.push(this.buildCssValue(orient(gapOffset), unit2));\n    }\n    return values;\n  }\n  cssOffsetGaps(options) {\n    const cloneCount = this.getCloneCount();\n    if (cloneCount && options.gap) {\n      const { orient } = this.Direction;\n      const { value, unit: unit2 } = this.parseCssValue(options.gap);\n      if (this.isFixedWidth(options)) {\n        return this.buildCssValue(orient(value * cloneCount), unit2);\n      }\n      const { perPage } = options;\n      const gaps = cloneCount / perPage;\n      return this.buildCssValue(orient(gaps * value), unit2);\n    }\n    return \"\";\n  }\n  resolve(prop) {\n    return camelToKebab(this.Direction.resolve(prop));\n  }\n  cssPadding(options, right) {\n    const { padding } = options;\n    const prop = this.Direction.resolve(right ? \"right\" : \"left\", true);\n    return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || \"0px\";\n  }\n  cssTrackHeight(options) {\n    let height = \"\";\n    if (this.isVertical()) {\n      height = this.cssHeight(options);\n      assert(height, '\"height\" is missing.');\n      height = `calc(${height} - ${this.cssPadding(options, false)} - ${this.cssPadding(options, true)})`;\n    }\n    return height;\n  }\n  cssHeight(options) {\n    return unit(options.height);\n  }\n  cssSlideWidth(options) {\n    return options.autoWidth ? \"\" : unit(options.fixedWidth) || (this.isVertical() ? \"\" : this.cssSlideSize(options));\n  }\n  cssSlideHeight(options) {\n    return unit(options.fixedHeight) || (this.isVertical() ? options.autoHeight ? \"\" : this.cssSlideSize(options) : this.cssHeight(options));\n  }\n  cssSlideSize(options) {\n    const gap = unit(options.gap);\n    return `calc((100%${gap && ` + ${gap}`})/${options.perPage || 1}${gap && ` - ${gap}`})`;\n  }\n  cssAspectRatio(options) {\n    const { heightRatio } = options;\n    return heightRatio ? `${1 / heightRatio}` : \"\";\n  }\n  buildCssValue(value, unit2) {\n    return `${value}${unit2}`;\n  }\n  parseCssValue(value) {\n    if (isString(value)) {\n      const number = parseFloat(value) || 0;\n      const unit2 = value.replace(/\\d*(\\.\\d*)?/, \"\") || \"px\";\n      return { value: number, unit: unit2 };\n    }\n    return { value, unit: \"px\" };\n  }\n  parseBreakpoints() {\n    const { breakpoints } = this.options;\n    this.breakpoints.push([\"default\", this.options]);\n    if (breakpoints) {\n      forOwn(breakpoints, (options, width) => {\n        this.breakpoints.push([width, merge(merge({}, this.options), options)]);\n      });\n    }\n  }\n  isFixedWidth(options) {\n    return !!options[this.Direction.resolve(\"fixedWidth\")];\n  }\n  isLoop() {\n    return this.options.type === LOOP;\n  }\n  isCenter(options) {\n    if (options.focus === \"center\") {\n      if (this.isLoop()) {\n        return true;\n      }\n      if (this.options.type === SLIDE) {\n        return !this.options.trimSpace;\n      }\n    }\n    return false;\n  }\n  isVertical() {\n    return this.options.direction === TTB;\n  }\n  buildClasses() {\n    const { options } = this;\n    return [\n      CLASS_ROOT,\n      `${CLASS_ROOT}--${options.type}`,\n      `${CLASS_ROOT}--${options.direction}`,\n      options.drag && `${CLASS_ROOT}--draggable`,\n      options.isNavigation && `${CLASS_ROOT}--nav`,\n      CLASS_ACTIVE,\n      !this.config.hidden && CLASS_RENDERED\n    ].filter(Boolean).join(\" \");\n  }\n  buildAttrs(attrs) {\n    let attr = \"\";\n    forOwn(attrs, (value, key) => {\n      attr += value ? ` ${camelToKebab(key)}=\"${value}\"` : \"\";\n    });\n    return attr.trim();\n  }\n  buildStyles(styles) {\n    let style = \"\";\n    forOwn(styles, (value, key) => {\n      style += ` ${camelToKebab(key)}:${value};`;\n    });\n    return style.trim();\n  }\n  renderSlides() {\n    const { slideTag: tag } = this.config;\n    return this.slides.map((content) => {\n      return `<${tag} ${this.buildAttrs(content.attrs)}>${content.html || \"\"}</${tag}>`;\n    }).join(\"\");\n  }\n  cover(content) {\n    const { styles, html = \"\" } = content;\n    if (this.options.cover && !this.options.lazyLoad) {\n      const src = html.match(/<img.*?src\\s*=\\s*(['\"])(.+?)\\1.*?>/);\n      if (src && src[2]) {\n        styles.background = `center/cover no-repeat url('${src[2]}')`;\n      }\n    }\n  }\n  generateClones(contents) {\n    const { classes } = this.options;\n    const count = this.getCloneCount();\n    const slides = contents.slice();\n    while (slides.length < count) {\n      push(slides, slides);\n    }\n    push(slides.slice(-count).reverse(), slides.slice(0, count)).forEach((content, index) => {\n      const attrs = assign({}, content.attrs, { class: `${content.attrs.class} ${classes.clone}` });\n      const clone = assign({}, content, { attrs });\n      index < count ? contents.unshift(clone) : contents.push(clone);\n    });\n  }\n  getCloneCount() {\n    if (this.isLoop()) {\n      const { options } = this;\n      if (options.clones) {\n        return options.clones;\n      }\n      const perPage = max(...this.breakpoints.map(([, options2]) => options2.perPage));\n      return perPage * ((options.flickMaxPages || 1) + 1);\n    }\n    return 0;\n  }\n  renderArrows() {\n    let html = \"\";\n    html += `<div class=\"${this.options.classes.arrows}\">`;\n    html += this.renderArrow(true);\n    html += this.renderArrow(false);\n    html += `</div>`;\n    return html;\n  }\n  renderArrow(prev) {\n    const { classes, i18n } = this.options;\n    const attrs = {\n      class: `${classes.arrow} ${prev ? classes.prev : classes.next}`,\n      type: \"button\",\n      ariaLabel: prev ? i18n.prev : i18n.next\n    };\n    return `<button ${this.buildAttrs(attrs)}><svg xmlns=\"${XML_NAME_SPACE}\" viewBox=\"0 0 ${SIZE} ${SIZE}\" width=\"${SIZE}\" height=\"${SIZE}\"><path d=\"${this.options.arrowPath || PATH}\" /></svg></button>`;\n  }\n  html() {\n    const { rootClass, listTag, arrows, beforeTrack, afterTrack, slider, beforeSlider, afterSlider } = this.config;\n    let html = \"\";\n    html += `<div id=\"${this.id}\" class=\"${this.buildClasses()} ${rootClass || \"\"}\">`;\n    html += `<style>${this.Style.build()}</style>`;\n    if (slider) {\n      html += beforeSlider || \"\";\n      html += `<div class=\"splide__slider\">`;\n    }\n    html += beforeTrack || \"\";\n    if (arrows) {\n      html += this.renderArrows();\n    }\n    html += `<div class=\"splide__track\">`;\n    html += `<${listTag} class=\"splide__list\">`;\n    html += this.renderSlides();\n    html += `</${listTag}>`;\n    html += `</div>`;\n    html += afterTrack || \"\";\n    if (slider) {\n      html += `</div>`;\n      html += afterSlider || \"\";\n    }\n    html += `</div>`;\n    return html;\n  }\n}\n\nexport { CLASSES, CLASS_ACTIVE, CLASS_ARROW, CLASS_ARROWS, CLASS_ARROW_NEXT, CLASS_ARROW_PREV, CLASS_AUTOPLAY, CLASS_CLONE, CLASS_CONTAINER, CLASS_INITIALIZED, CLASS_LIST, CLASS_LOADING, CLASS_NEXT, CLASS_PAGINATION, CLASS_PAGINATION_PAGE, CLASS_PAUSE, CLASS_PLAY, CLASS_PREV, CLASS_PROGRESS, CLASS_PROGRESS_BAR, CLASS_ROOT, CLASS_SLIDE, CLASS_SLIDER, CLASS_SPINNER, CLASS_TRACK, CLASS_VISIBLE, EVENT_ACTIVE, EVENT_ARROWS_MOUNTED, EVENT_ARROWS_UPDATED, EVENT_AUTOPLAY_PAUSE, EVENT_AUTOPLAY_PLAY, EVENT_AUTOPLAY_PLAYING, EVENT_CLICK, EVENT_DESTROY, EVENT_DRAG, EVENT_DRAGGED, EVENT_DRAGGING, EVENT_HIDDEN, EVENT_INACTIVE, EVENT_LAZYLOAD_LOADED, EVENT_MOUNTED, EVENT_MOVE, EVENT_MOVED, EVENT_NAVIGATION_MOUNTED, EVENT_PAGINATION_MOUNTED, EVENT_PAGINATION_UPDATED, EVENT_READY, EVENT_REFRESH, EVENT_REPOSITIONED, EVENT_RESIZE, EVENT_RESIZED, EVENT_SCROLL, EVENT_SCROLLED, EVENT_SHIFTED, EVENT_SLIDE_KEYDOWN, EVENT_UPDATED, EVENT_VISIBLE, EventBus, EventInterface, RequestInterval, STATUS_CLASSES, Splide, SplideRenderer, State, Throttle, Splide as default };\n"]},"metadata":{},"sourceType":"module"}